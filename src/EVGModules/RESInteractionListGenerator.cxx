//____________________________________________________________________________
/*!

\class   genie::RESInteractionListGenerator

\brief   Concrete implementations of the InteractionListGeneratorI interface.
         Generate a list of all the Interaction (= event summary) objects that
         can be generated by the RES EventGenerator.

\author  Costas Andreopoulos <C.V.Andreopoulos@rl.ac.uk>
         CCLRC, Rutherford Appleton Laboratory

\created May 13, 2005

*/
//____________________________________________________________________________

#include "EVGModules/RESInteractionListGenerator.h"
#include "EVGCore/InteractionList.h"
#include "Interaction/Interaction.h"
#include "Messenger/Messenger.h"

using namespace genie;

//___________________________________________________________________________
RESInteractionListGenerator::RESInteractionListGenerator() :
InteractionListGeneratorI("genie::RESInteractionListGenerator")
{

}
//___________________________________________________________________________
RESInteractionListGenerator::RESInteractionListGenerator(string config) :
InteractionListGeneratorI("genie::RESInteractionListGenerator", config)
{

}
//___________________________________________________________________________
RESInteractionListGenerator::~RESInteractionListGenerator()
{

}
//___________________________________________________________________________
InteractionList * RESInteractionListGenerator::CreateInteractionList(
                                       const InitialState & init_state) const
{
  LOG("InteractionList", pINFO) << "InitialState = " << init_state.AsString();

  const int n_nucc_channels = 3;
  const int n_nunc_channels = 4;

  SppChannel_t nucc_channels[n_nucc_channels] = {
                      kSpp_vp_cc_10100, kSpp_vn_cc_10010, kSpp_vn_cc_01100 };

  SppChannel_t nunc_channels[n_nunc_channels] = {
    kSpp_vp_nc_10010, kSpp_vp_nc_01100, kSpp_vn_nc_01010, kSpp_vn_nc_10001 };

  int nupdg  = init_state.GetProbePDGCode();

  if( !pdg::IsNeutrino(nupdg) && !pdg::IsAntiNeutrino(nupdg) ) {
     LOG("InteractionList", pWARN)
       << "Can not handle probe! Returning NULL InteractionList "
                         << "for init-state: " << init_state.AsString();
     return 0;
  }

  Target * inp_target = init_state.GetTargetPtr();
  bool hasP = (inp_target->Z() > 0);
  bool hasN = (inp_target->N() > 0);

  InteractionList * intlist = new InteractionList;

  // CC
  for(int i=0; i<n_nucc_channels; i++) {

     int struck_nucleon = SppChannel::InitStateNucleon(nucc_channels[i]);

     if( (struck_nucleon == kPdgProton  && hasP) ||
         (struck_nucleon == kPdgNeutron && hasN) ) {

        ProcessInfo proc_info(kScResonant, kIntWeakCC);
        Interaction * interaction = new Interaction(init_state, proc_info);

        Target * target = interaction->GetInitialStatePtr()->GetTargetPtr();

        target->SetStruckNucleonPDGCode(struck_nucleon);
        this->AddFinalStateInfo(interaction, nucc_channels[i]);

        intlist->push_back(interaction);
     }
  }

  // NC
  for(int i=0; i<n_nunc_channels; i++) {

     int struck_nucleon = SppChannel::InitStateNucleon(nunc_channels[i]);

     ProcessInfo proc_info(kScResonant, kIntWeakNC);
     Interaction * interaction = new Interaction(init_state, proc_info);

     Target * target = interaction->GetInitialStatePtr()->GetTargetPtr();

     target->SetStruckNucleonPDGCode(struck_nucleon);
     this->AddFinalStateInfo(interaction, nunc_channels[i]);

     intlist->push_back(interaction);
  }

  if(intlist->size() == 0) {
     LOG("InteractionList", pERROR)
       << "Returning NULL InteractionList for init-state: "
                                                  << init_state.AsString();
     delete intlist;
     return 0;
  }

  return intlist;
}
//___________________________________________________________________________
void RESInteractionListGenerator::AddFinalStateInfo(
                       Interaction * interaction, SppChannel_t sppchan) const
{
  int nproton  = 0;
  int nneutron = 0;
  int npiplus  = 0;
  int npi0     = 0;
  int npiminus = 0;

  int nucpdg = SppChannel::FinStateNucleon(sppchan);
  int pipdg  = SppChannel::FinStatePion(sppchan);

  if       ( nucpdg == kPdgProton  ) nproton  = 1;
  else if  ( nucpdg == kPdgNeutron ) nneutron = 1;
  else {
     LOG("InteractionGenerator", pERROR)
          << "Final state nucleon not a proton or a neutron! (pdg="
                                                             << nucpdg <<")";
  }

  if       ( pipdg == kPdgPiPlus  ) npiplus  = 1;
  else if  ( pipdg == kPdgPi0     ) npi0     = 1;
  else if  ( pipdg == kPdgPiMinus ) npiminus = 1;
  else {
     LOG("InteractionGenerator", pERROR)
              << "Final state pion not a pi+/pi-/pi0! (pdg=" << pipdg <<")";
  }

  XclsTag exclusive_tag;

  exclusive_tag.SetNNucleons (nproton, nneutron);
  exclusive_tag.SetNPions    (npiplus, npi0, npiminus);

  interaction->SetExclusiveTag(exclusive_tag);
}
//___________________________________________________________________________

