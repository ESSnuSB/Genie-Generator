//____________________________________________________________________________
/*!

\program gvld_nuxsec_vs_world_data

\brief   Compares the GENIE neutrino cross sections against the world data.

         Syntax:
           gvld_nuxsec_vs_world_data [-h host] [-u user] [-p passwd] -f files

         Options:

           [] Denotes an optional argument.

           -h NuVld MySQL URL (eg mysql://localhost/NuScat).
           -u NuVld MySQL username.
           -p NuVld MySQL password.
           -f Input files
              The input files should contain:
              - a cross section file (generated with gspl2root) which 
                contains at least the `nu_mu_n', `nu_mu_H1', nu_mu_bar_n' 
                and `nu_mu_bar_H1' folders
              - a list of nu_mu+n, nu_mu+p, nu_mu_bar+n, nu_mu_bar+p event
                files (in `gst' format), generated with an ~1/E energy 
                spectrum over a large energy range (eg 100 MeV - 100 GeV)
              - the files must be comma separated 
              - the cross section file must be first in the list
              - you can specify an arbitrary number of event files which will
                be chained together
              - you can have multiple sets of models (separated with an +)
              - you can associate a tag with each model (tag:list of files)
              The general syntax is:
               -f tagA:xsecA.root,eventA1.root,eventA2.root,...+tagB:xsecB.root,...

         Notes:
           The input ROOT files are the ones generated by GENIE's gspl2root
           utility. See the GENIE User Manual for more details.
           	      
         Example:
           To compare the model "new" (with cross sections in xsecn.root and
           event samples in evn0.root, evn1.root and evn2.root) and the 
           model "old" (with cross sections in xseco.root and event samples
           in evo0.root, evo1.root) against the world neutrino cross section
           data stored in a local MySQL dbase (URL = localhost/NuScat,
           username = costas, password = ^%@^!%@!*&@^),  type:

           shell$ gvld_nuxsec_vs_world_data \
                      -h mysql://localhost/NuScat \
                      -u costas \
                      -p ^%@^!%@!*&@^
		      -f new:xsecn.root,evn0.root,evn1.root,evn2.root+old:xseco.root,evo0.root,evo1.root

\author  Costas Andreopoulos <costas.andreopoulos \at stfc.ac.uk>
         STFC, Rutherford Appleton Laboratory

\created June 06, 2008 

\cpright Copyright (c) 2003-2009, GENIE Neutrino MC Generator Collaboration
         For the full text of the license visit http://copyright.genie-mc.org
         or see $GENIE/LICENSE
*/
//____________________________________________________________________________

#include <cassert>
#include <sstream>
#include <string>

#include <TSystem.h>
#include <TFile.h>
#include <TDirectory.h>
#include <TGraph.h>
#include <TPostScript.h>
#include <TH1D.h>
#include <TMath.h>
#include <TCanvas.h>
#include <TPavesText.h>
#include <TText.h>
#include <TStyle.h>
#include <TLegend.h>
#include <TChain.h>

#include "Conventions/GBuild.h"
#include "Messenger/Messenger.h"
#include "PDG/PDGUtils.h"
#include "PDG/PDGCodes.h"
#include "Utils/CmdLineArgParserUtils.h"
#include "Utils/CmdLineArgParserException.h"
#include "Utils/StringUtils.h"
#include "ValidationTools/NuVld/DBI.h"
#include "ValidationTools/NuVld/DBStatus.h"

using std::ostringstream;
using std::string;

using namespace genie;
using namespace genie::nuvld;

/* 
..............................................................................
NEUTRINO CROSS SECTION DATA
..............................................................................
ID   DESCRIPTION
0    neutrino      QEL [all]
1    neutrino      QEL [light targets]
2    neutrino      QEL [heavy targets]
3    anti-neutrino QEL [all]
4    anti-neutrino QEL [light targets]
5    anti-neutrino QEL [heavy targets]
6    neutrino      RES [all: v + p -> mu- + p + pi+]
7    neutrino      TOT [E>10]
8    anti-neutrino TOT [E>10]
9    neutrino      MPP [v + n -> l + p + pi+ + pi-]
10   neutrino      MPP [v + p -> l + p + pi+ + pi0]
11   neutrino      MPP [v + p -> l + n + pi+ + pi+]
..............................................................................
*/
const int    kNuXSecDataSets = 12;
const char * kNuXSecDataSetLabel[kNuXSecDataSets] = {
/* 0 */ "#nu_{#mu} QEL [all data]          ",
/* 1 */ "#nu_{#mu} QEL [light target data] ",
/* 2 */ "#nu_{#mu} QEL [heavy target data] ",
/* 3 */ "#bar{#nu_{#mu}} QEL [all data]          ",
/* 4 */ "#bar{#nu_{#mu}} QEL [light target data] ",
/* 5 */ "#bar{#nu_{#mu}} QEL [heavy target data] ",
/* 6 */ "#nu_{#mu} single-pi (#nu_{#mu} p -> #mu^{-} p #pi^{+}) ",
/* 7 */ "#nu_{#mu} TOT [E>10 GeV data]             ",
/* 8 */ "#bar{#nu_{#mu}} TOT [E>10 GeV data]             ",
/* 9 */ "#nu_{#mu} multi-pi (#nu_{#mu} n -> #mu^{-} p #pi^{+} #pi^{-})",
/*10 */ "#nu_{#mu} multi-pi (#nu_{#mu} p -> #mu^{-} p #pi^{+} #pi^{0})",
/*11 */ "#nu_{#mu} multi-pi (#nu_{#mu} p -> #mu^{-} n #pi^{+} #pi^{+})"
};
const char * kNuXSecKeyList[kNuXSecDataSets] = {
/* 0 */ "ANL_12FT,1;ANL_12FT,3;BEBC,12;BNL_7FT,3;FNAL_15FT,3;Gargamelle,2;SERP_A1,0;SERP_A1,1;SKAT,8",
/* 1 */ "ANL_12FT,1;ANL_12FT,3;BEBC,12;BNL_7FT,3;FNAL_15FT,3",
/* 2 */ "Gargamelle,2;SERP_A1,0;SERP_A1,1;SKAT,8",
/* 3 */ "BNL_7FT,2;Gargamelle,3;Gargamelle,5;SERP_A1,2;SKAT,9",
/* 4 */ "BNL_7FT,2",
/* 5 */ "Gargamelle,3;Gargamelle,5;SERP_A1,2;SKAT,9",
/* 6 */ "ANL_12FT,0;ANL_12FT,5;ANL_12FT,8;BEBC,4;BEBC,9;BEBC,13;BNL_7FT,5;FNAL_15FT,0;Gargamelle,4;SKAT,4;SKAT,5",
/* 7 */ "ANL_12FT,2;ANL_12FT,4;BEBC,0;BEBC,2;BEBC,5;BEBC,8;BNL_7FT,0;BNL_7FT,4;CCFR,2;CCFRR,0;CHARM,0;CHARM,4;FNAL_15FT,1;FNAL_15FT,2;Gargamelle,0;Gargamelle,10;Gargamelle,12;IHEP_ITEP,0;IHEP_ITEP,2;IHEP_JINR,0;SKAT,0",
/* 8 */ "BEBC,1;BEBC,3;BEBC,6;BEBC,7;BNL_7FT,1;CCFR,3;CHARM,1;CHARM,5;FNAL_15FT,4;FNAL_15FT,5;Gargamelle,1;Gargamelle,11;Gargamelle,13;IHEP_ITEP,1;IHEP_ITEP,3;IHEP_JINR,1",
/* 9 */ "ANL_12FT,11;BNL_7FT,8",
/*10 */ "ANL_12FT,12",
/*11 */ "ANL_12FT,13"
};
float kNuXSecERange[kNuXSecDataSets][2] = {
/* 0 */ { 0.1,  30.0},
/* 1 */ { 0.1,  30.0},
/* 2 */ { 0.1,  30.0},
/* 3 */ { 0.1,  30.0},
/* 4 */ { 0.1,  30.0},
/* 5 */ { 0.1,  30.0},
/* 6 */ { 0.1,  30.0},
/* 7 */ {10.0, 120.0},
/* 8 */ {10.0, 120.0},
/* 9 */ { 1.0, 120.0},
/*10 */ { 1.0, 120.0},
/*11 */ { 1.0, 120.0}
};

const int kNMaxNumModels = 5;

typedef DBQueryString             DBQ;
typedef DBTable<DBNuXSecTableRow> DBT;

// function prototypes
void     Init               (void);
void     Plot               (void);
void     End                (void);
void     AddCoverPage       (void);
void     OpenInputFiles     (void);
bool     Connect            (void);
DBQ      FormQuery          (const char * key_list, float emin,  float emax);
DBT *    Data               (int iset);
TGraph * Model              (int iset, int imodel);
TFile *  XSecFile           (int imodel);
TChain * EventTreeChain     (int imodel);
void     Draw               (vector<TGraph *> & models,  DBT * dbtable, const char * label);
void     Save               (vector<TGraph *> & models,  DBT * dbtable);
TH1F *   DrawFrame          (TGraph * gr0, TGraph * gr1);
TH1F *   DrawFrame          (double xmin, double xmax, double ymin, double yman);
void     Format             (TGraph* gr, int lcol, int lsty, int lwid, int mcol, int msty, double msiz);
void     GetCommandLineArgs (int argc, char ** argv);
void     PrintSyntax        (void);
bool     CheckRootFilename  (string filename);
string   OutputFileName     (string input_file_name);

// command-line arguments
string                       gOptDbURL;
string                       gOptDbUser;
string                       gOptDbPasswd;
map<string, vector<string> > gOptInputFiles;

// dbase information
const char * kDefDbURL = "mysql://localhost/NuScat";  

// globals
vector<string>  gModelTags           (kNMaxNumModels);
vector<TFile*>  gModelXSecFile       (kNMaxNumModels);
vector<TChain*> gModelEventTreeChain (kNMaxNumModels);
bool            gCmpWithData  = true;
DBI *           gDBI          = 0;
TPostScript *   gPS           = 0;
TCanvas *       gC            = 0;
TLegend *       gLS           = 0;
int             gNMod         = 0;

// model line styles
const int kLStyle    [kNMaxNumModels] = { 
   1,       2,        3,        5,            6 
}; 
string    kLStyleTxt [kNMaxNumModels] = { 
  "solid", "dashed", "dotted", "dot-dashed", "dot-dot-dashed" 
};

//_________________________________________________________________________________
int main(int argc, char ** argv)
{
  GetCommandLineArgs (argc,argv);

  Init();
  Plot();
  End();

  LOG("gvldtest", pINFO)  << "Done!";
  return 0;
}
//_________________________________________________________________________________
void Plot(void)
{
#ifdef __GENIE_MYSQL_ENABLED__

  // connect to the NuValidator MySQL dbase
  bool ok = Connect();
  if(!ok) {
    return;
  }
 
  // loop over data sets
  for(int iset = 0; iset < kNuXSecDataSets; iset++) {

    // get all measurements for the current channel
    //  from the NuValidator MySQL dbase
    DBT * data = Data(iset);

    // get the corresponding GENIE model prediction
    vector<TGraph*> models;
    for(int imodel=0; imodel< gNMod; imodel++) {
       models.push_back(Model(iset,imodel));
    }

    // draw & save
    Draw(models, data, kNuXSecDataSetLabel[iset]);
    Save(models, data);

    delete data;
  }
#endif
}
//_________________________________________________________________________________
void Init(void)
{
  LOG("vldtest", pNOTICE) << "Initializing...";;

  gC = new TCanvas("c","",20,20,500,650);
  gC->SetBorderMode(0);
  gC->SetFillColor(0);
  gC->SetGridx();
  gC->SetGridy();

  gLS = new TLegend(0.15,0.92,0.85,0.98);
  gLS -> SetFillColor(0);
  gLS -> SetBorderSize(1);

  // output file
  gPS = new TPostScript("genie_nuxec_vs_data.ps", 111);

  OpenInputFiles();
  AddCoverPage();

  gC->SetLogx();
  gC->SetLogy();
}
//_________________________________________________________________________________
void OpenInputFiles(void)
{
  LOG("vldtest", pNOTICE) << "Opening input files...";

  // number of models
  gNMod = gOptInputFiles.size();
  LOG("vldtest", pNOTICE) << "Number of models = " << gNMod;;

  if(gNMod == 0) return;

  int imodel=0;
  map<string, vector<string> >::const_iterator iter1 = gOptInputFiles.begin();
  for( ; iter1 != gOptInputFiles.end(); ++iter1) {

     LOG("vldtest", pNOTICE) << "** Model ID = " << imodel;

     string         model_tag = iter1->first;
     vector<string> files     = iter1->second;

     gModelTags           [imodel] = model_tag;
     gModelXSecFile       [imodel] = 0;
     gModelEventTreeChain [imodel] = 0;

     LOG("vldtest", pNOTICE) << "   Tag = " << model_tag;

     int ifile=0;
     vector<string>::const_iterator iter2 = files.begin();
     for( ; iter2 != files.end(); ++iter2) {

       string filename = *iter2;

       if(ifile==0) {
         LOG("vldtest", pNOTICE) << "   XSec file = " << filename;
         gModelXSecFile[imodel] = new TFile(filename.c_str(),"read");
       }
       if(ifile==1) {
          gModelEventTreeChain [imodel] = new TChain("gst");;
       }
       if(ifile>=1) {
          LOG("vldtest", pNOTICE) << "   Adding event file = " << filename;
          gModelEventTreeChain [imodel] -> Add(filename.c_str());
       }

       ifile++;
     }//iter2

     imodel++;
  }//iter1
}
//_________________________________________________________________________________
void AddCoverPage(void)
{
  // header
  gPS->NewPage();
  gC->Range(0,0,100,100);
  TPavesText hdr(10,40,90,70,3,"tr");
  hdr.AddText(" ");
  hdr.AddText("GENIE Neutrino Cross Section Comparisons with World Data");
  hdr.AddText(" ");
  hdr.AddText(" ");
  hdr.AddText(" ");
  for(int imodel=0; imodel< gNMod; imodel++) {
    ostringstream stream;
    stream << "model tag: " << gModelTags[imodel] 
           << "(" << kLStyleTxt[imodel] << ")";
    hdr.AddText(stream.str().c_str());
  }
  hdr.Draw();
  gC->Update();
}
//_________________________________________________________________________________
void End(void)
{
  LOG("vldtest", pNOTICE) << "Cleaning up...";

  gPS->Close();

  delete gC;
  delete gLS;
  delete gPS;
}
//_________________________________________________________________________________
// Corresponding GENIE prediction for the `iset' data set 
//.................................................................................
TGraph * Model(int iset, int imodel)
{
  TFile * xsec_file = XSecFile(imodel);
  if(!xsec_file) return 0;

  switch(iset) {
    case (0) :
    case (1) :
    case (2) :
    {
       TDirectory * dir  = (TDirectory *) xsec_file->Get("nu_mu_n");
       TGraph * model = (TGraph*) dir->Get("qel_cc_n");
       return model;
       break;
    }
    case (3) :
    case (4) :
    case (5) :
    {
       TDirectory * dir  = (TDirectory *) xsec_file->Get("nu_mu_bar_H1");
       TGraph * model = (TGraph*) dir->Get("qel_cc_p");
       return model;
       break;
    }
    case (6) :
    {
       TDirectory * dir  = (TDirectory *) xsec_file->Get("nu_mu_H1");
       TGraph * model = (TGraph*) dir->Get("res_cc_p");
       return model;
       break;
    }
    case (7) :
    {
       TDirectory * dir_n  = (TDirectory *) xsec_file->Get("nu_mu_n");
       TGraph * model_n = (TGraph*) dir_n->Get("tot_cc_n");
       TDirectory * dir_p  = (TDirectory *) xsec_file->Get("nu_mu_H1");
       TGraph * model_p = (TGraph*) dir_p->Get("tot_cc_p");
       const int n = 1000;
       double e[n], sig[n];
       for(int i=0; i<n; i++) {
         e  [i] = 5 + i*0.1;
         sig[i] = 0.5*(model_n->Eval(e[i]) + model_p->Eval(e[i]));
       }
       TGraph * model = new TGraph(n,e,sig);
       return model;
       break;
    }
    case (8) :
    {
       TDirectory * dir_n  = (TDirectory *) xsec_file->Get("nu_mu_bar_n");
       TGraph * model_n = (TGraph*) dir_n->Get("tot_cc_n");
       TDirectory * dir_p  = (TDirectory *) xsec_file->Get("nu_mu_bar_H1");
       TGraph * model_p = (TGraph*) dir_p->Get("tot_cc_p");
       const int n = 1000;
       double e[n], sig[n];
       for(int i=0; i<n; i++) {
         e  [i] = 5 + i*0.1;
         sig[i] = 0.5*(model_n->Eval(e[i]) + model_p->Eval(e[i]));
       }
       TGraph * model = new TGraph(n,e,sig);
       return model;
       break;
    }
    case (9) :
    {
       break;
    }
    case (10) :
    {
       break;
    }
    case (11) :
    {
       break;
    }
    default:
    {
       break;
    }
  }
  return 0;
}
//_________________________________________________________________________________
TFile * XSecFile(int imodel)
{
  return gModelXSecFile[imodel];
}
//_________________________________________________________________________________
TChain * EventTreeChain(int imodel)
{
  return gModelEventTreeChain[imodel];
}
//_________________________________________________________________________________
// Download cross section data from NuVld MySQL dbase 
//.................................................................................
bool Connect(void)
{
  if(!gCmpWithData) return true;

  // Get a data-base interface
  TSQLServer * sql_server = TSQLServer::Connect(
      gOptDbURL.c_str(),gOptDbUser.c_str(),gOptDbPasswd.c_str());

  if(!sql_server) return false;
  if(!sql_server->IsConnected()) return false;

  gDBI = new DBI(sql_server);
  return true;
}
//_________________________________________________________________________________
DBQ FormQuery(const char * key_list, float emin, float emax)
{
// forms a DBQueryString for extracting neutrino cross section data from the input 
// key-list and for the input energy range
//  
  ostringstream query_string;
  
  query_string 
    << "KEY-LIST:" << key_list
    << "$CUTS:Emin=" << emin << ";Emax=" << emax << "$DRAW_OPT:none$DB-TYPE:vN-XSec";
  
  DBQ query(query_string.str());
  
  return query;
}
//_________________________________________________________________________________
DBT * Data(int iset)
{
  if(!gCmpWithData) return 0;

  DBT * dbtable = new DBT;

  const char * keylist = kNuXSecKeyList[iset];
  float        e_min   = kNuXSecERange[iset][0];
  float        e_max   = kNuXSecERange[iset][1];

  DBQ query = FormQuery(keylist, e_min, e_max);
  assert( gDBI->FillTable(dbtable, query) == eDbu_OK );

  return dbtable;
}
//_________________________________________________________________________________
void Draw(vector<TGraph *> & models, DBT * dbtable, const char * title)
{
  if(models.size()==0 && !dbtable) return;

  gPS->NewPage();

  gC->Clear();
  gC->Divide(2,1);
  gC->GetPad(1)->SetPad("mplots_pad","",0.01,0.25,0.99,0.99);
  gC->GetPad(2)->SetPad("legend_pad","",0.01,0.01,0.99,0.24);
  gC->GetPad(1)->SetFillColor(0);
  gC->GetPad(1)->SetBorderMode(0);
  gC->GetPad(2)->SetFillColor(0);
  gC->GetPad(2)->SetBorderMode(0);
  gC->GetPad(1)->cd();
  gC->GetPad(1)->SetBorderMode(0);
  gC->GetPad(1)->SetLogx();
  gC->GetPad(1)->SetLogy();

  if(title) {
    gLS->SetHeader(title);
  }

  TLegend * legend = new TLegend(0.01, 0.01, 0.99, 0.99);
  legend->SetFillColor(0);
  legend->SetTextSize(0.08);

  TH1F * hframe = 0;
  bool have_frame = false;

  // have data points to plot?
  if(dbtable) {
    TGraphAsymmErrors * graph = dbtable->GetGraph("all-noE");

    // create frame from the data point range
    double xmin  = ( graph->GetX() )[TMath::LocMin(graph->GetN(),graph->GetX())];
    double xmax  = ( graph->GetX() )[TMath::LocMax(graph->GetN(),graph->GetX())];
    double ymin  = ( graph->GetY() )[TMath::LocMin(graph->GetN(),graph->GetY())];
    double ymax  = ( graph->GetY() )[TMath::LocMax(graph->GetN(),graph->GetY())];
    hframe = (TH1F*) gC->GetPad(1)->DrawFrame(0.5*xmin, 0.4*ymin, 1.2*xmax, 2.0*ymax);
    hframe->Draw();
    have_frame = true;

    //
    // draw current data set
    //
    MultiGraph * mgraph = dbtable->GetMultiGraph("all-noE");
    for(unsigned int igraph = 0; igraph < mgraph->NGraphs(); igraph++) {
       mgraph->GetGraph(igraph)->Draw("P");
    }
    mgraph->FillLegend("LP", legend);
  }//dbtable?

  // have model prediction to plot?
  if(models.size()>0) {
     if(!have_frame) {
        // the data points have not been plotted
        // create a frame from this graph range
        double xmin  = ( models[0]->GetX() )[TMath::LocMin(models[0]->GetN(),models[0]->GetX())];
        double xmax  = ( models[0]->GetX() )[TMath::LocMax(models[0]->GetN(),models[0]->GetX())];
        double ymin  = ( models[0]->GetY() )[TMath::LocMin(models[0]->GetN(),models[0]->GetY())];
        double ymax  = ( models[0]->GetY() )[TMath::LocMax(models[0]->GetN(),models[0]->GetY())];
        hframe = (TH1F*) gC->GetPad(1)->DrawFrame(0.5*xmin, 0.4*ymin, 1.2*xmax, 2.0*ymax);
        hframe->Draw();
     }
     for(int imodel=0; imodel<gNMod; imodel++) {
       TGraph * plot = models[imodel];
       if(plot) {
         int lsty = kLStyle[imodel];     
         Format(plot,1,lsty,2,1,1,1);
         plot->Draw("L");
       }
     }
  }//model?

  hframe->GetXaxis()->SetTitle("E_{#nu} (GeV)");
  hframe->GetYaxis()->SetTitle("#sigma_{#nu} (1E-38 cm^{2})");

  gLS->Draw();

  gC->GetPad(2)->cd();
  legend->Draw();

  gC->GetPad(2)->Update();
  gC->Update();
}
//_________________________________________________________________________________
void Save(vector<TGraph *> & models, DBT * dbtable)
{
  if(models.size()==0 && !dbtable) return;


}
//_________________________________________________________________________________
// Formatting
//.................................................................................
TH1F* DrawFrame(TGraph * gr0, TGraph * gr1)
{
  double xmin = 1E-5;
  double xmax = 1;
  double ymin = 1E-5;
  double ymax = 1;

  if(gr0) {  
    TAxis * x0 = gr0 -> GetXaxis();
    TAxis * y0 = gr0 -> GetYaxis();
    xmin = x0 -> GetXmin();
    xmax = x0 -> GetXmax();
    ymin = y0 -> GetXmin();
    ymax = y0 -> GetXmax();
  }
  if(gr1) {
     TAxis * x1 = gr1 -> GetXaxis();
     TAxis * y1 = gr1 -> GetYaxis();
     xmin = TMath::Min(xmin, x1 -> GetXmin());
     xmax = TMath::Max(xmax, x1 -> GetXmax());
     ymin = TMath::Min(ymin, y1 -> GetXmin());
     ymax = TMath::Max(ymax, y1 -> GetXmax());
  }
  xmin *= 0.5;
  xmax *= 1.5;
  ymin *= 0.5;
  ymax *= 1.5;
  xmin = TMath::Max(0.1, xmin);
  
  return DrawFrame(xmin, xmax, ymin, ymax);
}
//_________________________________________________________________________________
TH1F* DrawFrame(double xmin, double xmax, double ymin, double ymax)
{
  TH1F * hf = (TH1F*) gC->DrawFrame(xmin, ymin, xmax, ymax);
  hf->GetXaxis()->SetTitle("E (GeV)");
  hf->GetYaxis()->SetTitle("#sigma (10^{-38} cm^{2})");
  hf->GetYaxis()->SetTitleSize(0.03);
  hf->GetYaxis()->SetTitleOffset(1.3);
  hf->GetXaxis()->SetLabelSize(0.03);
  hf->GetYaxis()->SetLabelSize(0.03);
  return hf;
}
//_________________________________________________________________________________
void Format(
    TGraph* gr, int lcol, int lsty, int lwid, int mcol, int msty, double msiz)
{
  if(!gr) return;

  if (lcol >= 0) gr -> SetLineColor   (lcol);
  if (lsty >= 0) gr -> SetLineStyle   (lsty);
  if (lwid >= 0) gr -> SetLineWidth   (lwid);

  if (mcol >= 0) gr -> SetMarkerColor (mcol);
  if (msty >= 0) gr -> SetMarkerStyle (msty);
  if (msiz >= 0) gr -> SetMarkerSize  (msiz);
}
//_________________________________________________________________________________
// Parsing command-line arguments, check/form filenames, etc
//.................................................................................
void GetCommandLineArgs(int argc, char ** argv)
{
  LOG("gvldtest", pNOTICE) << "*** Parsing commad line arguments";

  try {
    string input_data = genie::utils::clap::CmdLineArgAsString(argc,argv,'f');
    LOG("vldtest", pNOTICE) << input_data;

    // split input string per model
    vector<string> mvec;
    if(input_data.find("+") != string::npos) {
       mvec  = utils::str::Split(input_data, "+");
    } else {
       mvec.push_back(input_data);
    }

    LOG("vldtest", pNOTICE) << "Input models: " << mvec.size();

    vector<string>::iterator mvecit = mvec.begin();
    for( ; mvecit != mvec.end(); ++mvecit) {
       string mcurr = *mvecit;
         
       LOG("vldtest", pNOTICE) << "Current Entry: " << mcurr;;

       // split into model name and list of files
       vector<string> mcurvec = utils::str::Split(mcurr, ":");
      
       assert(mcurvec.size()==2);
       string model_name = mcurvec[0];
       string file_list  = mcurvec[1];

       LOG("vldtest", pNOTICE) << "Current Entry / Model Tag: " << model_name;
       LOG("vldtest", pNOTICE) << "Current Entry / File List: " << file_list;
  
       // split file list
       vector<string> filevec;
       if(file_list.find(",") != string::npos) {
           filevec = utils::str::Split(file_list, ",");
       } else {
           filevec.push_back(file_list);
       }

       gOptInputFiles.insert(
         map<string, vector<string> >::value_type(model_name, filevec)
       );
  
    } // inputs
    
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
    }
  }

  // check whether to compare with data
  gCmpWithData = true;

  // get DB URL
  try {
     gOptDbURL = utils::clap::CmdLineArgAsString(argc,argv,'h');
  } catch(exceptions::CmdLineArgParserException e) {
     if(!e.ArgumentFound()) {
       gOptDbURL = kDefDbURL;
     }
  }

  // get DB username
  try {
     gOptDbUser = utils::clap::CmdLineArgAsString(argc,argv,'u');
  } catch(exceptions::CmdLineArgParserException e) {
     if(!e.ArgumentFound()) {
       gCmpWithData = false;
     }
  }

  // get DB passwd
  try {
     gOptDbPasswd = utils::clap::CmdLineArgAsString(argc,argv,'p');
  } catch(exceptions::CmdLineArgParserException e) {
     if(!e.ArgumentFound()) {
       gCmpWithData = false;
     }
  }

}
//_________________________________________________________________________________
void PrintSyntax(void)
{
  LOG("gvldtest", pNOTICE)
    << "\n\n" << "Syntax:" << "\n"
    << "   gvld_nuxsec_vs_world_data [-h host] [-u user] [-p passwd] -f files\n";
}
//_________________________________________________________________________________
bool CheckRootFilename(string filename)
{
  if(filename.size() == 0) return false;

  bool is_accessible = ! (gSystem->AccessPathName(filename.c_str()));
  if (!is_accessible) {
   LOG("gvldtest", pERROR)
       << "The input ROOT file [" << filename << "] is not accessible";
   return false;
  }
  return true;
}
//_________________________________________________________________________________
string OutputFileName(string inpname)
{
// Builds the output filename based on the name of the input filename
// Perfors the following conversion: name.root -> name.nuxsec_test.ps

  unsigned int L = inpname.length();

  // if the last 4 characters are "root" (ROOT file extension) then
  // remove them
  if(inpname.substr(L-4, L).find("root") != string::npos) {
    inpname.erase(L-4, L);
  }

  ostringstream name;
  name << inpname << "nuxsec_test.ps";

  return gSystem->BaseName(name.str().c_str());
}
//_________________________________________________________________________________

