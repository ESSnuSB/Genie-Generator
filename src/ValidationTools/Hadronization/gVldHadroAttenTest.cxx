//____________________________________________________________________________
/* !

\program gvld_hadroatten_test

\brief   Compares GENIE with hadron attenuation measurements from semi-inclusive
         electron-nucleus scattering data

         Syntax:
           gvld_hadroatten_test [-g genie_inputs]

         Options:

           [] Denotes an optional argument.

           -g An XML file with GENIE inputs (event samples)
              Multiple models can be included in that file, each identified 
              by a "name" (all model predictions will be overlayed).

              <?xml version="1.0" encoding="ISO-8859-1"?>
              <vld_inputs>
                 <model name="a_model_name">
                   <evt_file format="gst"> /path/model_1/evtfile0.root </evt_file>
                   <evt_file format="gst"> /path/model_1/evtfile1.root </evt_file>
                   <evt_file format="gst"> /path/model_1/evtfile2.root </evt_file>
                   ...
                 </model>

                 <model name="another_model_name">
                   <evt_file format="gst"> /path/model_2/evtfile0.root </evt_file>
                   <evt_file format="gst"> /path/model_2/evtfile1.root </evt_file>
                   <evt_file format="gst"> /path/model_2/evtfile2.root </evt_file>
                   ...
                 </model>
                 ...
              </vld_inputs>

         Notes:
           * The input event files are `gst' summary ntuples generated by 
             GENIE gntpc utility.
             See the GENIE Physics & User Manual for more details.
             The files will be chained together. 
             They should contain sufficient statistics of the following samples:
                -  ?
             The samples should be generated with an ? energy spectrum over 
             ? GeV - ? GeV.
           * A script for preparing inputs for this benchmark test can be 
             found in:
             $GENIE/src/scripts/production/rutherford_tier2/?.pl
             The script has been developed for the RAL/Tier2 farm. 
             Modify it accordingly for your own system.
             
\author  Athans Hatzikoutelis <a.hatzikoutelis \at lancaster.ac.uk>
         Lancaster University

         Costas Andreopoulos <costas.andreopoulos \at stfc.ac.uk>
         STFC, Rutherford Appleton Laboratory

\created June 06, 2008 

\cpright Copyright (c) 2003-2011, GENIE Neutrino MC Generator Collaboration
         For the full text of the license visit http://copyright.genie-mc.org
         or see $GENIE/LICENSE
*/
//____________________________________________________________________________

#include <cstdlib>
#include <cassert>
#include <sstream>
#include <string>

#include <TSystem.h>
#include <TFile.h>
#include <TDirectory.h>
#include <TGraphAsymmErrors.h>
#include <TPostScript.h>
#include <TH1D.h>
#include <TMath.h>
#include <TCanvas.h>
#include <TPavesText.h>
#include <TText.h>
#include <TLatex.h>
#include <TStyle.h>
#include <TLegend.h>
#include <TChain.h>

#include "Conventions/GBuild.h"
#include "Messenger/Messenger.h"
#include "PDG/PDGUtils.h"
#include "PDG/PDGCodes.h"
#include "Utils/CmdLnArgParser.h"
#include "Utils/StringUtils.h"
#include "Utils/Style.h"
#include "Utils/VldTestInputs.h"

using std::ostringstream;
using std::string;

using namespace genie;
using namespace genie::utils::vld;

/* 
..............................................................................
DATA
..............................................................................
*/
const int    kNDataSets = 12;
const char * kDataSetLabel[kNDataSets] = {
/*  0 */ "pi+ multiplicity ratio (He/D) vs Q2 / HERMES / 27.6 GeV",
/*  1 */ "K+  multiplicity ratio (He/D) vs Q2 / HERMES / 27.6 GeV",
/*  2 */ "p   multiplicity ratio (He/D) vs Q2 / HERMES / 27.6 GeV",
/*  3 */ "pi+ multiplicity ratio (Ne/D) vs Q2 / HERMES / 27.6 GeV",
/*  4 */ "K+  multiplicity ratio (Ne/D) vs Q2 / HERMES / 27.6 GeV",
/*  5 */ "p   multiplicity ratio (Ne/D) vs Q2 / HERMES / 27.6 GeV",
/*  6 */ "pi+ multiplicity ratio (Kr/D) vs Q2 / HERMES / 27.6 GeV",
/*  7 */ "K+  multiplicity ratio (Kr/D) vs Q2 / HERMES / 27.6 GeV",
/*  8 */ "p   multiplicity ratio (Kr/D) vs Q2 / HERMES / 27.6 GeV",
/*  9 */ "pi+ multiplicity ratio (Xe/D) vs Q2 / HERMES / 27.6 GeV",
/* 10 */ "K+  multiplicity ratio (Xe/D) vs Q2 / HERMES / 27.6 GeV",
/* 11 */ "p   multiplicity ratio (Xe/D) vs Q2 / HERMES / 27.6 GeV"
//
// add more
//
};
const char * kDataSetXAxisLabel[kNDataSets] = {
/*  0 */ "Q2 (GeV^{2})",
/*  1 */ "Q2 (GeV^{2})",
/*  2 */ "Q2 (GeV^{2})",
/*  3 */ "Q2 (GeV^{2})",
/*  4 */ "Q2 (GeV^{2})",
/*  5 */ "Q2 (GeV^{2})",
/*  6 */ "Q2 (GeV^{2})",
/*  7 */ "Q2 (GeV^{2})",
/*  8 */ "Q2 (GeV^{2})",
/*  9 */ "Q2 (GeV^{2})",
/* 10 */ "Q2 (GeV^{2})",
/* 11 */ "Q2 (GeV^{2})"
//
// add more
//
};
const char * kDataSetYAxisLabel[kNDataSets] = {
/*  0 */ "R_{#pi^{+}} (He/D)",
/*  1 */ "R_{K^{+}} (He/D)",
/*  2 */ "R_{p} (He/D)",
/*  3 */ "R_{#pi^{+}} (Ne/D)",
/*  4 */ "R_{K^{+}} (Ne/D)",
/*  5 */ "R_{p} (Ne/D)",
/*  6 */ "R_{#pi^{+}} (Kr/D)",
/*  7 */ "R_{K^{+}} (Kr/D)",
/*  8 */ "R_{p} (Kr/D)",
/*  9 */ "R_{#pi^{+}} (Xe/D)",
/* 10 */ "R_{K^{+}} (Xe/D)",
/* 11 */ "R_{p} (Xe/D)"
//
// add more
//
};
const char * kDigitizedDataFile[kNDataSets] = {
/*  0 */ "NPB780_2007_fig2-RhA_vsQ2-pi+_He.dat",
/*  1 */ "NPB780_2007_fig2-RhA_vsQ2-K+_He.dat",
/*  2 */ "NPB780_2007_fig2-RhA_vsQ2-p_He.dat",
/*  3 */ "NPB780_2007_fig2-RhA_vsQ2-pi+_Ne.dat",
/*  4 */ "NPB780_2007_fig2-RhA_vsQ2-K+_Ne.dat",
/*  5 */ "NPB780_2007_fig2-RhA_vsQ2-p_Ne.dat",
/*  6 */ "NPB780_2007_fig2-RhA_vsQ2-pi+_Kr.dat",
/*  7 */ "NPB780_2007_fig2-RhA_vsQ2-K+_Kr.dat",
/*  8 */ "NPB780_2007_fig2-RhA_vsQ2-p_Kr.dat",
/*  9 */ "NPB780_2007_fig2-RhA_vsQ2-pi+_Xe.dat",
/* 10 */ "NPB780_2007_fig2-RhA_vsQ2-K+_Xe.dat",
/* 11 */ "NPB780_2007_fig2-RhA_vsQ2-p_Xe.dat"
};

// function prototypes
void               Init               (void);
void               Run                (void);
void               End                (void);
void               AddCoverPage       (void);
TGraphAsymmErrors* Data               (int iset);
TH1D *             Model              (int iset, int imodel);
void               Draw               (int iset);
void               GetCommandLineArgs (int argc, char ** argv);
void               PrintSyntax        (void);

// command-line arguments
VldTestInputs  gOptGenieInputs;

// globals
TPostScript * gPS = 0;
TCanvas *     gC  = 0;

// plotting consts

const int kNCx = 1; // number of columns in TCanvas::Divide()
const int kNCy = 1; // number of rows    in TCanvas::Divide()

// model line styles
const int kNMaxNumModels = 5;
const int kLStyle    [kNMaxNumModels] = { 
   1,       2,        3,        5,            6 
}; 
string    kLStyleTxt [kNMaxNumModels] = { 
  "solid", "dashed", "dotted", "dot-dashed", "dot-dot-dashed" 
};

//_________________________________________________________________________________
int main(int argc, char ** argv)
{
  GetCommandLineArgs (argc,argv);

  Init();
  Run ();
  End ();
  
  LOG("gvldtest", pINFO)  << "Done!";
  return 0;
}
//_________________________________________________________________________________
void Run(void)
{
  // loop over data sets
  for(int iset = 0; iset < kNDataSets; iset++) 
  {
    Draw(iset);
  }
}
//_________________________________________________________________________________
void Init(void)
{
  LOG("vldtest", pNOTICE) << "Initializing...";;

  utils::style::SetDefaultStyle();

  gC = new TCanvas("c","",20,20,500,650);
  gC->SetBorderMode(0);
  gC->SetFillColor(0);
  gC->SetGridx();
  gC->SetGridy();

  // output file
  gPS = new TPostScript("genie_hadronization_medium_effects.ps", 111);

  AddCoverPage();

  gC->SetLogx();
  gC->SetLogy();
}
//_________________________________________________________________________________
void AddCoverPage(void)
{
  // header
  gPS->NewPage();
  gC->Range(0,0,100,100);
  TPavesText hdr(10,40,90,70,3,"tr");
  hdr.AddText(" ");
  hdr.AddText("GENIE Hadronization, Medium Effects: Comparisons with data");
  hdr.AddText(" ");
  hdr.AddText(" ");
  for(int imodel=0; imodel< gOptGenieInputs.NModels(); imodel++) {
    ostringstream stream;
    stream << "model tag: " << gOptGenieInputs.ModelTag(imodel)
           << " (" << kLStyleTxt[imodel] << " line)";
    hdr.AddText(stream.str().c_str());
  }
  hdr.AddText(" ");
  hdr.Draw();
  gC->Update();
}
//_________________________________________________________________________________
void End(void)
{
  LOG("vldtest", pNOTICE) << "Cleaning up...";

  gPS->Close();

  delete gC;
  delete gPS;
}
//_________________________________________________________________________________
// Corresponding GENIE prediction for the `iset' data set 
//.................................................................................
TH1D* Model(int iset, int imodel)
{
  LOG("vldtest", pNOTICE) 
    << "Getting GENIE prediction (model ID = " 
    << imodel << ", data set ID = " << iset << ")";

  TChain * event_chain = gOptGenieInputs.EvtChain(imodel);
  if(!event_chain) {
     LOG("vldtest", pNOTICE) 
        << "No corresponding event chain.";
     return 0;
  }

  const int    nbins = 20;
  const double Q2min =  0;
  const double Q2max = 10;

  TH1D * RhA = new TH1D("RhA","",nbins,Q2min,Q2max);
  TH1D * yD  = new TH1D("yD", "",nbins,Q2min,Q2max);

  switch(iset) {

    //
    // Data sets 0-11
    // Cuts: v > 6 GeV, z > 0.2, xF > 0
    //

    // pi+ multiplicity ratio (He/D) vs Q2 - HERMES / 27.6 GeV
    case (0) :
    {
      event_chain->Draw("Q2>>yD", "nfpip*((abs(Ev-27.6)<0.01)&&(Z==1)&&(A==2)&&(Ev-El>6.)&&(Ef/(y*Ev)>0.2)&&(pdgf==211))","goff");
      LOG("vldtest", pNOTICE) 
        << "Used " << event_chain->GetSelectedRows() << " entries";
      event_chain->Draw("Q2>>RhA","nfpip*((abs(Ev-27.6)<0.01)&&(Z==2)&&(A==4)&&(Ev-El>6.)&&(Ef/(y*Ev)>0.2)&&(pdgf==211))","goff");
      LOG("vldtest", pNOTICE) 
        << "Used " << event_chain->GetSelectedRows() << " entries";
      RhA->Divide(yD);
      break;
    }

    // K+  multiplicity ratio (He/D) vs Q2 - HERMES / 27.6 GeV
    case (1) :
    {
      event_chain->Draw("Q2>>yD",  "nfkp *(abs(Ev-27.6)<0.01&&Z==1&&A==2)","goff");
      event_chain->Draw("Q2>>RhA", "nfkp *(abs(Ev-27.6)<0.01&&Z==2&&A==4)","goff");
      RhA->Divide(yD);
      break;
    }

    // p   multiplicity ratio (He/D) vs Q2 - HERMES / 27.6 GeV
    case (2) :
    {
      event_chain->Draw("Q2>>yD",  "nfp  *(abs(Ev-27.6)<0.01&&Z==1&&A==2)","goff");
      event_chain->Draw("Q2>>RhA", "nfp  *(abs(Ev-27.6)<0.01&&Z==2&&A==4)","goff");
      RhA->Divide(yD);
      break;
    }

    //
    // add more
    //
    // pi+ multiplicity ratio (Ne/D) vs Q2 - HERMES / 27.6 GeV
    // K+  multiplicity ratio (Ne/D) vs Q2 - HERMES / 27.6 GeV
    // p   multiplicity ratio (Ne/D) vs Q2 - HERMES / 27.6 GeV
    // pi+ multiplicity ratio (Kr/D) vs Q2 - HERMES / 27.6 GeV
    // K+  multiplicity ratio (Kr/D) vs Q2 - HERMES / 27.6 GeV
    // p   multiplicity ratio (Kr/D) vs Q2 - HERMES / 27.6 GeV
    // pi+ multiplicity ratio (Xe/D) vs Q2 - HERMES / 27.6 GeV
    // K+  multiplicity ratio (Xe/D) vs Q2 - HERMES / 27.6 GeV
    // p   multiplicity ratio (Xe/D) vs Q2 - HERMES / 27.6 GeV

    default:
    {

    }
  }

  return RhA;
}
//_________________________________________________________________________________
TGraphAsymmErrors * Data(int iset)
{
  LOG("vldtest", pNOTICE) 
    << "Loading experimental data set ID = " << iset;

  ostringstream filename;
  filename << gSystem->Getenv("GENIE")
           << "/data/hadronization_validation/medium_effects/"
           << kDigitizedDataFile[iset];

  LOG("vldtest", pNOTICE) 
    << "Reading from data file: " << filename.str().c_str();

  TTree digitized_data;
  digitized_data.ReadFile(filename.str().c_str(), "Q2/D:R/D:Rp/D:Rm/D");

  digitized_data.Draw("Q2:R:Rp:Rm","","GOFF");

  const int n = digitized_data.GetSelectedRows();
  double * Q2  = new double[n];
  double * R   = new double[n];
  double * dRp = new double[n];
  double * dRm = new double[n];
  for(int i=0; i<n; i++) {
    Q2 [i] = digitized_data.GetV1()[i];
    R  [i] = digitized_data.GetV2()[i];
    dRp[i] = TMath::Abs(R[i] - digitized_data.GetV3()[i]);
    dRm[i] = TMath::Abs(R[i] - digitized_data.GetV4()[i]);

    LOG("vldtest", pNOTICE) 
       << "Q2 =  " << Q2[i] << " GeV^2 -> "
       << "RA = " << R[i] << " +" << dRp[i] << " -" << dRm[i];
  }

  TGraphAsymmErrors * gr = new TGraphAsymmErrors(n,Q2,R,0,0,dRp,dRm);

  utils::style::Format(gr, kBlack, kSolid, 1, kBlack, 20, 1.5);

  delete [] Q2;
  delete [] R;
  delete [] dRp;
  delete [] dRm;

  return gr;
}
//_________________________________________________________________________________
void Draw(int iset)
{
  // get data for the current comparison
  TGraph * data = Data(iset);

  // get the corresponding GENIE model prediction
  vector<TH1D*> models;
  for(int imodel=0; imodel< gOptGenieInputs.NModels(); imodel++) {
    TH1D * h = Model(iset,imodel);
    models.push_back(h);
  }

  if(models.size()==0 && !data) return;

  int plots_per_page = kNCx * kNCy;
  int iplot = 1 + iset % plots_per_page;
    
  if(iplot == 1) {   
     gPS->NewPage();
     gC -> Clear();
     gC -> Divide(kNCx,kNCy);
  }
  
  gC -> GetPad(iplot) -> Range(0,0,100,100);
  gC -> GetPad(iplot) -> SetFillColor(0);
  gC -> GetPad(iplot) -> SetBorderMode(0);
  gC -> GetPad(iplot) -> cd();

  double xmin = 0.0, scale_xmin = 0.5;
  double xmax = 0.0, scale_xmax = 1.2;
  double ymin = 0.0, scale_ymin = 0.4;
  double ymax = 0.0, scale_ymax = 1.2;
       
  TH1F * hframe = 0;
  bool have_frame = false;

  // have data points to plot?
  if(data) {
    // create frame from the data point range
    xmin  = ( data->GetX() )[TMath::LocMin(data->GetN(),data->GetX())];
    xmax  = ( data->GetX() )[TMath::LocMax(data->GetN(),data->GetX())];
    ymin  = ( data->GetY() )[TMath::LocMin(data->GetN(),data->GetY())];
    ymax  = ( data->GetY() )[TMath::LocMax(data->GetN(),data->GetY())];
    hframe = (TH1F*) gC->GetPad(iplot)->DrawFrame(
        scale_xmin*xmin, scale_ymin*ymin, scale_xmax*xmax, scale_ymax*ymax);
    hframe->Draw();
    have_frame = true;

    // draw current data set
    data->Draw("P");
  }//dbtable?

  // have model prediction to plot?
  if(models.size()>0) {
     for(int imodel=0; imodel<gOptGenieInputs.NModels(); imodel++) {

       TH1D * plot = models[imodel];
       if(plot) {
         int lsty = kLStyle[imodel];     
         utils::style::Format(plot,1,lsty,2,1,1,1);
         plot->Draw("CSAME");
       }
     }
  }//model?

  // axes label
  hframe->GetXaxis()->SetTitle(kDataSetXAxisLabel[iset]);
  hframe->GetYaxis()->SetTitle(kDataSetYAxisLabel[iset]);

  // title
  double xtitle = scale_xmin*xmin + 0.2*(scale_xmax*xmax-scale_xmin*xmin);
  double ytitle = 1.01*scale_ymax*ymax; 
  TLatex * title = new TLatex(xtitle, ytitle, kDataSetLabel[iset]);
  title->SetTextSize(0.022);
  title->Draw();

  // update    
  gC->GetPad(iplot)->Update();
  gC->Update();
}
//_________________________________________________________________________________
// Parsing command-line arguments, check/form filenames, etc
//.................................................................................
void GetCommandLineArgs(int argc, char ** argv)
{
  LOG("gvldtest", pNOTICE) << "*** Parsing command line arguments";

  CmdLnArgParser parser(argc,argv);

  // get GENIE inputs
  if(parser.OptionExists('g')) {
     string inputs = parser.ArgAsString('g');
     bool ok = gOptGenieInputs.LoadFromFile(inputs);
     if(!ok) {
        LOG("gvldtest", pFATAL) 
           << "Could not read your validation program inputs from: " << inputs;
        gAbortingInErr = true;
        exit(1);
     }
  } else {
     LOG("gvldtest", pNOTICE) << " *** You didn't specify any GENIE MC outputs!";
     LOG("gvldtest", pNOTICE) << " *** Will plot only digitized expt data";
  }
}
//_________________________________________________________________________________
void PrintSyntax(void)
{
  LOG("gvldtest", pNOTICE)
    << "\n\n" << "Syntax:" << "\n"
    << "  gvld_hadroatten_test [-g genie_inputs.xml]\n";
}
//_________________________________________________________________________________

