//____________________________________________________________________________
/*!

\program gvld_e_qel_xsec (IN DEVELOPMENT)

\brief   Compares GENIE with QE electron scattering data for various nuclei.

         The data (currently ? data points) stored at GENIE's MySQL dbase 
         originate from D.Day's online dbase:
         http://faculty.virginia.edu/qes-archive/

         Syntax:
           gvld_e_qel_xsec 
                [-h host] [-u user] [-p passwd] [-g input_file_list]

         Options:

           [] Denotes an optional argument.

           -h NuVld MySQL URL (eg mysql://localhost/NuScat).
           -u NuVld MySQL username.
           -p NuVld MySQL password.
           -g An XML file with GENIE inputs (cross sections and event samples
              for decomposing the inclusive cross section to exclusive cross 
              sections). Multiple models can be included in that file, each 
              identified by a "name" (all model predictions will be overlayed).

              <?xml version="1.0" encoding="ISO-8859-1"?>
              <vld_inputs>
                 <model name="a_model_name">
                   <xsec_file>             /path/model_1/xsec.root </xsec_file>
                   <evt_file format="gst"> /path/model_1/ev0.root  </evt_file>
                   <evt_file format="gst"> /path/model_1/ev1.root  </evt_file>
                   <evt_file format="gst"> /path/model_1/ev2.root  </evt_file>
                   ...
                 </model>

                 <model name="another_model_name">
                   <xsec_file>             /path/model_2/xsec.root </xsec_file>
                   <evt_file format="gst"> /path/model_2/ev0.root  </evt_file>
                   <evt_file format="gst"> /path/model_2/ev1.root  </evt_file>
                   <evt_file format="gst"> /path/model_2/ev2.root  </evt_file>
                   ...
                 </model>
                 ...
              </vld_inputs>

        Notes:
           * The input ROOT cross section files are the ones generated by 
             GENIE's gspl2root utility. 
             See the GENIE Physics & User Manual for more details.
             It should contain at least the follwing directories:
                - ...
                - ...
           * The input event files are `gst' summary ntuples generated by 
             GENIE gntpc utility.
             See the GENIE Physics & User Manual for more details.
             The files will be chained together. 
             They should contain sufficient statistics of the following samples: 
                - ...
                - ...
         * A script for preparing inputs for this benchmark test can be   
             found in:
             $GENIE/src/scripts/production/rutherford_tier2/???
             The script has been developed for the RAL/Tier2 farm. 
             Modify it accordingly for your own system.

         Example:

            % gvld_e_qel_xsec -u costas \
                              -p &^@7287 \
                              -h mysql://localhost/NuScat
                              -g /some/path/inputs.xml

\author  Costas Andreopoulos <costas.andreopoulos \at stfc.ac.uk>
         STFC, Rutherford Appleton Laboratory

\created Oct 16, 2009 

\cpright Copyright (c) 2003-2010, GENIE Neutrino MC Generator Collaboration
         For the full text of the license visit http://copyright.genie-mc.org
         or see $GENIE/LICENSE
*/
//____________________________________________________________________________

#include <cstdlib>
#include <cassert>
#include <sstream>
#include <string>

#include <TROOT.h>
#include <TSystem.h>
#include <TFile.h>
#include <TDirectory.h>
#include <TGraph.h>
#include <TPostScript.h>
#include <TLatex.h>
#include <TH1D.h>
#include <TH2D.h>
#include <TMath.h>
#include <TCanvas.h>
#include <TPavesText.h>
#include <TText.h>
#include <TStyle.h>
#include <TLegend.h>
#include <TBox.h>

#include "Conventions/GBuild.h"
#include "Conventions/Constants.h"
#include "Conventions/Units.h"
#include "Messenger/Messenger.h"
#include "PDG/PDGUtils.h"
#include "PDG/PDGCodes.h"
#include "Utils/CmdLnArgParser.h"
#include "Utils/VldTestInputs.h"
#include "Utils/Style.h"
#include "ValidationTools/NuVld/DBI.h"
#include "ValidationTools/NuVld/DBStatus.h"

using std::ostringstream;
using std::string;

using namespace genie;
using namespace genie::nuvld;
using namespace genie::constants;
using namespace genie::utils::vld;

/* 
..............................................................................
QUASI-ELASTIC ELECTRON SCATTERING CROSS SECTION DATA 
..............................................................................
*/
const int    kElXSecDataSets = 12;
const char * kElXSecDataSetLabel[kElXSecDataSets] = 
{
/*  0 */ "C12(e,e') E = 0.620 GeV, #theta = 36.00^{o}",
/*  1 */ "C12(e,e') E = 0.620 GeV, #theta = 60.00^{o}",
/*  2 */ "C12(e,e') E = 0.680 GeV, #theta = 36.00^{o}",
/*  3 */ "C12(e,e') E = 0.680 GeV, #theta = 60.00^{o}",
/*  4 */ "C12(e,e') E = 0.730 GeV, #theta = 37.10^{o}",
/*  5 */ "C12(e,e') E = 0.961 GeV, #theta = 37.50^{o}",
/*  6 */ "C12(e,e') E = 1.108 GeV, #theta = 37.50^{o}",
/*  7 */ "C12(e,e') E = 1.299 GeV, #theta = 37.50^{o}",
/*  8 */ "C12(e,e') E = 1.500 GeV, #theta = 11.95^{o}",
/*  9 */ "C12(e,e') E = 1.500 GeV, #theta = 13.54^{o}",
/* 10 */ "C12(e,e') E = 1.501 GeV, #theta = 37.50^{o}",
/* 11 */ "C12(e,e') E = 2.020 GeV, #theta = 20.02^{o}"
//
// ... add more
//
};
const char * kElXSecKeyList[kElXSecDataSets] = {
/*  0 */ "database keys - data not in NuVld yet",
/*  1 */ "database keys - data not in NuVld yet",
/*  2 */ "database keys - data not in NuVld yet",
/*  3 */ "database keys - data not in NuVld yet",
/*  4 */ "database keys - data not in NuVld yet",
/*  5 */ "database keys - data not in NuVld yet",
/*  6 */ "database keys - data not in NuVld yet",
/*  7 */ "database keys - data not in NuVld yet",
/*  8 */ "database keys - data not in NuVld yet",
/*  9 */ "database keys - data not in NuVld yet",
/* 10 */ "database keys - data not in NuVld yet",
/* 11 */ "database keys - data not in NuVld yet",
/* 12 */ "database keys - data not in NuVld yet"
//
// ... add more
//
};
double kElXSecEnergy[kElXSecDataSets] = {
/*  0 */ 0.620,
/*  1 */ 0.620,
/*  2 */ 0.680,
/*  3 */ 0.680,
/*  4 */ 0.730,
/*  5 */ 0.961,
/*  6 */ 1.108,
/*  7 */ 1.299,
/*  8 */ 1.500,
/*  9 */ 1.500,
/* 10 */ 1.501,
/* 11 */ 2.020
//
// ... add more
//
};
double kElXSecTheta[kElXSecDataSets] = {
/*  0 */ 36.00,
/*  1 */ 60.00,
/*  2 */ 36.00,
/*  3 */ 60.00,
/*  4 */ 37.10,
/*  5 */ 37.50,
/*  6 */ 37.50,
/*  7 */ 37.50,
/*  8 */ 11.95,
/*  9 */ 13.54,
/* 10 */ 37.50,
/* 11 */ 20.02
//
// ... add more
//
};
int kElXSecTarget[kElXSecDataSets] = {
/*  0 */ 1000060120,
/*  1 */ 1000060120,
/*  2 */ 1000060120,
/*  3 */ 1000060120,
/*  4 */ 1000060120,
/*  5 */ 1000060120,
/*  6 */ 1000060120,
/*  7 */ 1000060120,
/*  8 */ 1000060120,
/*  9 */ 1000060120,
/* 10 */ 1000060120,
/* 11 */ 1000060120
//
// ... add more
//
};

typedef DBQueryString                 DBQ;
typedef DBTable<DBElDiffXSecTableRow> DBT; // replace with proper table

// function prototypes
void     Init               (void);
void     Plot               (void);
void     End                (void);
void     AddCoverPage       (void);
bool     Connect            (void);
DBQ      FormQuery          (const char * key_list, double energy, double theta);
DBT *    Data               (int iset);
TGraph * Model              (int iset, int imodel);
void     Draw               (int iset);
void     GetCommandLineArgs (int argc, char ** argv);
void     PrintSyntax        (void);

// command-line arguments
string         gOptDbURL;
string         gOptDbUser;
string         gOptDbPasswd;
VldTestInputs  gOptGenieInputs;

// dbase information
const char * kDefDbURL = "mysql://localhost/NuScat";  

// globals
bool            gCmpWithData  = true;
DBI *           gDBI          = 0;
TPostScript *   gPS           = 0;
TCanvas *       gC            = 0;
bool            gShowModel    = false;

// consts
const int kNCx = 2; // number of columns in TCanvas::Divide()
const int kNCy = 2; // number of rows    in TCanvas::Divide()

// model line styles
const int kNMaxNumModels = 5;
const int kLStyle    [kNMaxNumModels] = {
   1,       2,        3,        5,            6
};
string    kLStyleTxt [kNMaxNumModels] = {
  "solid", "dashed", "dotted", "dot-dashed", "dot-dot-dashed"
};

//_________________________________________________________________________________
int main(int argc, char ** argv)
{
  GetCommandLineArgs (argc,argv);

  Init();
  Plot();
  End();

  LOG("gvldtest", pINFO)  << "Done!";
  return 0;
}
//_________________________________________________________________________________
void Plot(void)
{
#ifdef __GENIE_MYSQL_ENABLED__

  // connect to the NuValidator MySQL dbase
  bool ok = Connect();
  if(!ok) {
    return;
  }
 
  // loop over data sets
  for(int iset = 0; iset < kElXSecDataSets; iset++) 
  {
    Draw(iset);
  }
#endif
}
//_________________________________________________________________________________
void Init(void)
{
  LOG("vldtest", pNOTICE) << "Initializing...";

  // genie style
  utils::style::SetDefaultStyle();

  // canvas
  gC = new TCanvas("c","",20,20,500,650);
  gC->SetBorderMode(0);
  gC->SetFillColor(0);
  gC->SetGridx();
  gC->SetGridy();

  // output postscript file
  gPS = new TPostScript("genie_eqel_vs_data.ps", 111);

  // cover page
  AddCoverPage();
}
//_________________________________________________________________________________
void AddCoverPage(void)
{
  // header
  gPS->NewPage();
  gC->Range(0,0,100,100);
  TPavesText hdr(10,40,90,70,3,"tr");
  hdr.AddText(" ");
  hdr.AddText("GENIE QE Electron Scattering Model vs Data");
  hdr.AddText(" ");
  hdr.AddText(" ");
  for(int imodel=0; imodel< gOptGenieInputs.NModels(); imodel++) {
    ostringstream stream;
    stream << "model tag: " << gOptGenieInputs.ModelTag(imodel)
           << " (" << kLStyleTxt[imodel] << " line)";
    hdr.AddText(stream.str().c_str());
  }
  hdr.AddText(" ");
  hdr.Draw();
  gC->Update();
}
//_________________________________________________________________________________
void End(void)
{
  LOG("vldtest", pNOTICE) << "Cleaning up...";

  gPS->Close();

  delete gC;
  delete gPS;
}
//_________________________________________________________________________________
// Corresponding GENIE prediction for the `iset' data set 
//.................................................................................
TGraph * Model(int iset, int imodel)
{
  LOG("vldtest", pNOTICE) 
    << "Getting GENIE prediction (model ID = " 
    << imodel << ", data set ID = " << iset << ")";

  TFile * xsec_file = gOptGenieInputs.XSecFile(imodel);
  if(!xsec_file) {
     LOG("vldtest", pWARN)
        << "No corresponding cross section file";
     return 0;
  }
      
  TChain * event_chain = gOptGenieInputs.EvtChain(imodel);
  if(!event_chain) {
     LOG("vldtest", pWARN)
        << "No corresponding event chain.";
     return 0;
  }

  // electron energy and scattering angle
  double E        = kElXSecEnergy [iset]; // GeV
  double theta    = kElXSecTheta  [iset]; // deg

  double dE       = 0.01; // GeV
  double costheta = TMath::Cos(kPi*theta/180.);

  // total cross section
  TGraph * xsec_em_gr = 0; // get it from the input xsec_file
  if(!xsec_em_gr) {
     LOG("vldtest", pWARN)
        << "Null E/M cross section graph";
     return 0;
  }
  double xsec_em = xsec_em_gr->Eval(E);
  if(xsec_em <= 0) {
     LOG("vldtest", pWARN)
        << "Null E/M cross section graph";
     return 0;
  }

  //
  // book histograms
  //

  // E', final state primary lepton energy
  double Ep_min   = 0;
  double Ep_max   = E;
  double Ep_bin   = 0.01;
  double Ep_nbins = (Ep_max-Ep_min)/Ep_bin;

  // theta, scattering angle
  double costh_min   = -1;
  double costh_max   =  1;
  double costh_bin   =  0.01;
  double costh_nbins = (costh_max-costh_min)/costh_bin;

  TH2D * h2EpOmega = 
     new TH2D("h2EpOmega",  "N=N(E',Omega)|{fixed:E}", 
         Ep_nbins, Ep_min, Ep_max, costh_nbins, costh_min, costh_max);

  //
  // estimate d^2 sigma / dE' dOmega at the current incoming lepton energy E0
  //

  char cut[500];
  Form(cut,"em&&(fabs(Ev-%d)<%d)", E, dE);

  event_chain->Draw("((pxv*pxl+pyv*pyl+pzv*pzl)/(Ev*El)):El>>h2EpOmega", cut, "GOFF");

  double integral = h2EpOmega->Integral("width");
  if(integral <= 0) {
     LOG("vldtest", pWARN)
        << "Non-positive d^2N / dEp dOmega integral";
     return 0;
  }
  double normalization = 2*kPi*xsec_em/integral;

  h2EpOmega->Scale(normalization); // units: 1E-38 cm^2 / GeV /sterad

  //
  // now pick a slice at selected theta and return 
  // d^2 sigma / dE' dOmega (fixed: E, theta) = f(v = E-E') 
  // in the same units as the expt data (nbar/GeV/sterad)
  //

  int N = Ep_nbins;

  double * x = new double[N]; // v
  double * y = new double[N]; // d^2 sigma / dE' dOmega

  int costheta_bin = h2EpOmega->GetYaxis()->FindBin(costheta);

  for(int i = 0; i < h2EpOmega->GetNbinsX(); i++) {
    int Ep_bin = i+1;
    double Ep  = h2EpOmega->GetXaxis()->GetBinCenter(Ep_bin);

    double v      = E - Ep;
    double d2xsec = h2EpOmega->GetBinContent(Ep_bin, costheta_bin);

    x[i] = v;
    y[i] = d2xsec;
  }

  TGraph * gr = new TGraph(N,x,y);

  delete [] x;
  delete [] y;

  return gr;
}
//_________________________________________________________________________________
// Download cross section data from NuVld MySQL dbase 
//.................................................................................
bool Connect(void)
{
  if(!gCmpWithData) return true;

  // Get a data-base interface
  TSQLServer * sql_server = TSQLServer::Connect(
      gOptDbURL.c_str(),gOptDbUser.c_str(),gOptDbPasswd.c_str());

  if(!sql_server) return false;
  if(!sql_server->IsConnected()) return false;

  gDBI = new DBI(sql_server);
  return true;
}
//_________________________________________________________________________________
DBQ FormQuery(const char * key_list, double energy, double theta)
{
// forms a DBQueryString for extracting neutrino cross section data from the input 
// key-list and for the input energy range
//  
  ostringstream query_string;
  
/*
  query_string 
    << "KEY-LIST:" << key_list
    << "$CUTS:E_min=" << energy-0.001 << ";E_max=" << energy+0.001 
    << ";Theta_min=" << theta-0.001 << ";Theta_max=" << theta+0.001 
    << "$DRAW_OPT:none$DB-TYPE:eN-Diff-XSec";
*/

  //
  //
  // .... ..... .....
  // .... ..... .....
  // .... ..... .....
  // .... ..... .....
  // .... ..... .....
  //
  //
  
  DBQ query(query_string.str());
  
  return query;
}
//_________________________________________________________________________________
DBT * Data(int iset)
{
  if(!gCmpWithData) return 0;

  DBT * dbtable = new DBT;

  const char * keylist = kElXSecKeyList[iset];
  double       energy  = kElXSecEnergy [iset];
  double       theta   = kElXSecTheta  [iset];

  DBQ query = FormQuery(keylist, energy, theta);
  assert( gDBI->FillTable(dbtable, query) == eDbu_OK );

  return dbtable;
}
//_________________________________________________________________________________
void Draw(int iset)
{
  // get all measurements for the current channel from the NuValidator MySQL dbase
  DBT * dbtable = Data(iset);

  // get the corresponding GENIE model prediction
  vector<TGraph*> models;
  for(int imodel=0; imodel< gOptGenieInputs.NModels(); imodel++) {
       models.push_back(Model(iset,imodel));
  }
     
  if(models.size()==0 && !dbtable) return;


  int plots_per_page = kNCx * kNCy;
  int iplot = 1 + iset % plots_per_page;
  if(iplot == 1) {
     gPS->NewPage();
     gC -> Clear();
     gC -> Divide(kNCx,kNCy);
  }

  gC -> GetPad(iplot) -> Range(0,0,100,100);
  gC -> GetPad(iplot) -> SetFillColor(0);
  gC -> GetPad(iplot) -> SetBorderMode(0);
  gC -> GetPad(iplot) -> cd();

  double xmin = 0.0, scale_xmin = 0.5;
  double xmax = 0.0, scale_xmax = 1.2;
  double ymin = 0.0, scale_ymin = 0.4;
  double ymax = 0.0, scale_ymax = 1.2;

  TH1F * hframe = 0;
  bool have_frame = false;

  if(dbtable) {
    TGraphAsymmErrors * graph = dbtable->GetGraph("err","W2");
    xmin  = ( graph->GetX() )[TMath::LocMin(graph->GetN(),graph->GetX())];
    xmax  = ( graph->GetX() )[TMath::LocMax(graph->GetN(),graph->GetX())];
    ymin  = ( graph->GetY() )[TMath::LocMin(graph->GetN(),graph->GetY())];
    ymax  = ( graph->GetY() )[TMath::LocMax(graph->GetN(),graph->GetY())];
    hframe = (TH1F*) gC->GetPad(1)->DrawFrame(
        scale_xmin*xmin, scale_ymin*ymin, scale_xmax*xmax, scale_ymax*ymax);
    have_frame = true;

    MultiGraph * mgraph = dbtable->GetMultiGraph("err","v");
    for(unsigned int igraph = 0; igraph < mgraph->NGraphs(); igraph++) {
       utils::style::Format(mgraph->GetGraph(igraph), 1,1,1,1,8,0.8);
       mgraph->GetGraph(igraph)->Draw("P");
    }
  }//dbtable?

  if(models.size()>0) {
    if(!have_frame) {
       xmin  = ( models[0]->GetX() )[TMath::LocMin(models[0]->GetN(),models[0]->GetX())];
       xmax  = ( models[0]->GetX() )[TMath::LocMax(models[0]->GetN(),models[0]->GetX())];
       ymin  = ( models[0]->GetY() )[TMath::LocMin(models[0]->GetN(),models[0]->GetY())];
       ymax  = ( models[0]->GetY() )[TMath::LocMax(models[0]->GetN(),models[0]->GetY())];
       hframe = (TH1F*) gC->GetPad(1)->DrawFrame(
         scale_xmin*xmin, scale_ymin*ymin, scale_xmax*xmax, scale_ymax*ymax);
    }
    for(int imodel=0; imodel<gOptGenieInputs.NModels(); imodel++) {
       TGraph * plot = models[imodel];
       if(plot) {
         int lsty = kLStyle[imodel];
         utils::style::Format(plot,1,lsty,2,1,1,1);
         plot->Draw("L");
       }
    }
  }

  //hframe->Draw();
  hframe->GetXaxis()->SetTitle("v (GeV)");
  hframe->GetYaxis()->SetTitle("d^{2}#sigma / d#Omega dE^{'} (nb/sr/GeV)");

  // title
  TLatex * title = new TLatex(
     scale_ymin*xmin,1.01*scale_ymax*ymax,kElXSecDataSetLabel[iset]);
  title->SetTextSize(0.04);
  title->Draw();

  gC->GetPad(iplot)->Update();
  gC->Update();
}
//_________________________________________________________________________________
// Parsing command-line arguments, check/form filenames, etc
//.................................................................................
void GetCommandLineArgs(int argc, char ** argv)
{
  LOG("gvldtest", pNOTICE) << "*** Parsing command line arguments";

  CmdLnArgParser  parser(argc, argv);

  gCmpWithData = true;

  // get GENIE inputs
  if(parser.OptionExists('g')) {
     string inputs = parser.ArgAsString('g');
     bool ok = gOptGenieInputs.LoadFromFile(inputs);
     if(!ok) {
        LOG("gvldtest", pFATAL) 
           << "Could not read validation program inputs: " << inputs;
        gAbortingInErr = true;
        exit(1);
     }
  }
      
  // get DB URL
  if(parser.OptionExists('h')) {
     gOptDbURL = parser.ArgAsString('h');
  } else {
     gOptDbURL = kDefDbURL;
  }

  // get DB username
  if(parser.OptionExists('u')) {
     gOptDbUser = parser.ArgAsString('u');
  } else {
     gCmpWithData = false;
  }

  // get DB passwd
  if(parser.OptionExists('p')) {
     gOptDbPasswd = parser.ArgAsString('p');
  } else {
     gCmpWithData = false;
  }

}
//_________________________________________________________________________________
void PrintSyntax(void)
{
  LOG("gvldtest", pNOTICE)
    << "\n\n" << "Syntax:" << "\n"
    << "  gvld_e_qel_xsec [-h host] [-u user] [-p passwd] [-g input_file_list]\n";
}
//_________________________________________________________________________________

