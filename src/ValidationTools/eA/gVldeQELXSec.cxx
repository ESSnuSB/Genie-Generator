//____________________________________________________________________________
/*!

\program gvld_e_qel_xsec (IN DEVELOPMENT)

\brief   Compares GENIE with QE electron scattering data for various nuclei.

         The data (currently ? data points) stored at GENIE's MySQL dbase 
         originate from D.Day's online dbase:
         http://faculty.virginia.edu/qes-archive/

         Syntax:
           gvld_e_qel_xsec 
                [-h host] [-u user] [-p passwd] [-g input_file_list]

         Options:

           [] Denotes an optional argument.

           -h NuVld MySQL URL (eg mysql://localhost/NuScat).
           -u NuVld MySQL username.
           -p NuVld MySQL password.
           -g An XML file with GENIE inputs (cross sections and event samples
              for decomposing the inclusive cross section to exclusive cross 
              sections). Multiple models can be included in that file, each 
              identified by a "name" (all model predictions will be overlayed).

              <?xml version="1.0" encoding="ISO-8859-1"?>
              <vld_inputs>
                 <model name="a_model_name">
                   <xsec_file>             /path/model_1/xsec.root </xsec_file>
                   <evt_file format="gst"> /path/model_1/ev0.root  </evt_file>
                   <evt_file format="gst"> /path/model_1/ev1.root  </evt_file>
                   <evt_file format="gst"> /path/model_1/ev2.root  </evt_file>
                   ...
                 </model>

                 <model name="another_model_name">
                   <xsec_file>             /path/model_2/xsec.root </xsec_file>
                   <evt_file format="gst"> /path/model_2/ev0.root  </evt_file>
                   <evt_file format="gst"> /path/model_2/ev1.root  </evt_file>
                   <evt_file format="gst"> /path/model_2/ev2.root  </evt_file>
                   ...
                 </model>
                 ...
              </vld_inputs>

        Notes:
           * The input ROOT cross section files are the ones generated by 
             GENIE's gspl2root utility. 
             See the GENIE Physics & User Manual for more details.
             It should contain at least the follwing directories:
                - ...
                - ...
           * The input event files are `gst' summary ntuples generated by 
             GENIE gntpc utility.
             See the GENIE Physics & User Manual for more details.
             The files will be chained together. 
             They should contain sufficient statistics of the following samples: 
                - ...
                - ...
         * A script for preparing inputs for this benchmark test can be   
             found in:
             $GENIE/src/scripts/production/rutherford_tier2/???
             The script has been developed for the RAL/Tier2 farm. 
             Modify it accordingly for your own system.

         Example:

            % gvld_e_qel_xsec -u costas \
                              -p &^@7287 \
                              -h mysql://localhost/NuScat
                              -g /some/path/inputs.xml

\author  Costas Andreopoulos <costas.andreopoulos \at stfc.ac.uk>
         STFC, Rutherford Appleton Laboratory

\created Oct 16, 2009 

\cpright Copyright (c) 2003-2009, GENIE Neutrino MC Generator Collaboration
         For the full text of the license visit http://copyright.genie-mc.org
         or see $GENIE/LICENSE
*/
//____________________________________________________________________________

#include <cstdlib>
#include <cassert>
#include <sstream>
#include <string>

#include <TROOT.h>
#include <TSystem.h>
#include <TFile.h>
#include <TDirectory.h>
#include <TGraph.h>
#include <TPostScript.h>
#include <TLatex.h>
#include <TH1D.h>
#include <TMath.h>
#include <TCanvas.h>
#include <TPavesText.h>
#include <TText.h>
#include <TStyle.h>
#include <TLegend.h>
#include <TBox.h>

#include "Conventions/GBuild.h"
#include "Conventions/Constants.h"
#include "Conventions/Units.h"
#include "Messenger/Messenger.h"
#include "PDG/PDGUtils.h"
#include "PDG/PDGCodes.h"
#include "Utils/CmdLineArgParserUtils.h"
#include "Utils/CmdLineArgParserException.h"
#include "Utils/VldTestInputs.h"
#include "ValidationTools/NuVld/DBI.h"
#include "ValidationTools/NuVld/DBStatus.h"

using std::ostringstream;
using std::string;

using namespace genie;
using namespace genie::nuvld;
using namespace genie::constants;
using namespace genie::utils::vld;

/* 
..............................................................................
QUASI-ELASTIC ELECTRON SCATTERING CROSS SECTION DATA 
..............................................................................
*/
const int    kElXSecDataSets = 1;
const char * kElXSecDataSetLabel[kElXSecDataSets] = 
{
/*  0 */ "16O(e,e') E = 0.7 GeV, #theta = 32^{o}"
//
// ... add more
//
};
const char * kElXSecKeyList[kElXSecDataSets] = {
/*  0 */ "database keys"
//
// ... add more
//
};
float kElXSecEnergy[kElXSecDataSets] = {
/*  0 */ 0.700
//
// ... add more
//
};
float kElXSecTheta[kElXSecDataSets] = {
/*  0 */ 32.00,
//
// ... add more
//
};
int kElXSecTarget[kElXSecDataSets] = {
/*  0 */ 1000080160
//
// ... add more
//
};

typedef DBQueryString                 DBQ;
typedef DBTable<DBElDiffXSecTableRow> DBT; // replace with proper table

// function prototypes
void     Init               (void);
void     Plot               (void);
void     End                (void);
void     SetStyle           (void);
void     AddCoverPage       (void);
bool     Connect            (void);
DBQ      FormQuery          (const char * key_list, float energy, float theta);
DBT *    Data               (int iset);
TGraph * Model              (int iset, int imodel);
void     Draw               (int iset);
void     Format             (TGraph* gr, int lcol, int lsty, int lwid, int mcol, int msty, double msiz);
void     GetCommandLineArgs (int argc, char ** argv);
void     PrintSyntax        (void);

// command-line arguments
string         gOptDbURL;
string         gOptDbUser;
string         gOptDbPasswd;
VldTestInputs  gOptGenieInputs;

// dbase information
const char * kDefDbURL = "mysql://localhost/NuScat";  

// globals
bool            gCmpWithData  = true;
DBI *           gDBI          = 0;
TPostScript *   gPS           = 0;
TCanvas *       gC            = 0;
bool            gShowModel    = false;

// consts
const int kNCx = 2; // number of columns in TCanvas::Divide()
const int kNCy = 2; // number of rows    in TCanvas::Divide()

// model line styles
const int kNMaxNumModels = 5;
const int kLStyle    [kNMaxNumModels] = {
   1,       2,        3,        5,            6
};
string    kLStyleTxt [kNMaxNumModels] = {
  "solid", "dashed", "dotted", "dot-dashed", "dot-dot-dashed"
};

//_________________________________________________________________________________
int main(int argc, char ** argv)
{
  GetCommandLineArgs (argc,argv);

  Init();
  Plot();
  End();

  LOG("gvldtest", pINFO)  << "Done!";
  return 0;
}
//_________________________________________________________________________________
void Plot(void)
{
#ifdef __GENIE_MYSQL_ENABLED__

  // connect to the NuValidator MySQL dbase
  bool ok = Connect();
  if(!ok) {
    return;
  }
 
  // loop over data sets
  for(int iset = 0; iset < kElXSecDataSets; iset++) 
  {
    Draw(iset);
  }
#endif
}
//_________________________________________________________________________________
void Init(void)
{
  LOG("vldtest", pNOTICE) << "Initializing...";

  // genie style
  SetStyle();

  // canvas
  gC = new TCanvas("c","",20,20,500,650);
  gC->SetBorderMode(0);
  gC->SetFillColor(0);
  gC->SetGridx();
  gC->SetGridy();

  // output postscript file
  gPS = new TPostScript("genie.ps", 111);

  // cover page
  AddCoverPage();
}
//_________________________________________________________________________________
void AddCoverPage(void)
{
  // header
  gPS->NewPage();
  gC->Range(0,0,100,100);
  TPavesText hdr(10,40,90,70,3,"tr");
  hdr.AddText(" ");
  hdr.AddText("GENIE QE Electron Scattering Model vs Data");
  hdr.AddText(" ");
  hdr.AddText(" ");
  for(int imodel=0; imodel< gOptGenieInputs.NModels(); imodel++) {
    ostringstream stream;
    stream << "model tag: " << gOptGenieInputs.ModelTag(imodel)
           << " (" << kLStyleTxt[imodel] << " line)";
    hdr.AddText(stream.str().c_str());
  }
  hdr.AddText(" ");
  hdr.Draw();
  gC->Update();
}
//_________________________________________________________________________________
void End(void)
{
  LOG("vldtest", pNOTICE) << "Cleaning up...";

  gPS->Close();

  delete gC;
  delete gPS;
}
//_________________________________________________________________________________
// Corresponding GENIE prediction for the `iset' data set 
//.................................................................................
TGraph * Model(int iset, int imodel)
{
  LOG("vldtest", pNOTICE) 
    << "Getting GENIE prediction (model ID = " 
    << imodel << ", data set ID = " << iset << ")";

  TFile * xsec_file = gOptGenieInputs.XSecFile(imodel);
  if(!xsec_file) {
     LOG("vldtest", pNOTICE)
        << "No corresponding cross section file";
     return 0;
  }
      
  TChain * event_chain = gOptGenieInputs.EvtChain(imodel);
  if(!event_chain) {
     LOG("vldtest", pNOTICE)
        << "No corresponding event chain.";
  }

  //
  //
  // .... ..... .....
  // .... ..... .....
  // .... ..... .....
  // .... ..... .....
  // .... ..... .....
  //
  //

  return 0;
}
//_________________________________________________________________________________
// Download cross section data from NuVld MySQL dbase 
//.................................................................................
bool Connect(void)
{
  if(!gCmpWithData) return true;

  // Get a data-base interface
  TSQLServer * sql_server = TSQLServer::Connect(
      gOptDbURL.c_str(),gOptDbUser.c_str(),gOptDbPasswd.c_str());

  if(!sql_server) return false;
  if(!sql_server->IsConnected()) return false;

  gDBI = new DBI(sql_server);
  return true;
}
//_________________________________________________________________________________
DBQ FormQuery(const char * key_list, float energy, float theta)
{
// forms a DBQueryString for extracting neutrino cross section data from the input 
// key-list and for the input energy range
//  
  ostringstream query_string;
  
/*
  query_string 
    << "KEY-LIST:" << key_list
    << "$CUTS:E_min=" << energy-0.001 << ";E_max=" << energy+0.001 
    << ";Theta_min=" << theta-0.001 << ";Theta_max=" << theta+0.001 
    << "$DRAW_OPT:none$DB-TYPE:eN-Diff-XSec";
*/

  //
  //
  // .... ..... .....
  // .... ..... .....
  // .... ..... .....
  // .... ..... .....
  // .... ..... .....
  //
  //
  
  DBQ query(query_string.str());
  
  return query;
}
//_________________________________________________________________________________
DBT * Data(int iset)
{
  if(!gCmpWithData) return 0;

  DBT * dbtable = new DBT;

  const char * keylist = kElXSecKeyList[iset];
  float        energy  = kElXSecEnergy [iset];
  float        theta   = kElXSecTheta  [iset];

  DBQ query = FormQuery(keylist, energy, theta);
  assert( gDBI->FillTable(dbtable, query) == eDbu_OK );

  return dbtable;
}
//_________________________________________________________________________________
void Draw(int iset)
{
  // get all measurements for the current channel from the NuValidator MySQL dbase
  DBT * dbtable = Data(iset);

  // get the corresponding GENIE model prediction
  vector<TGraph*> models;
  for(int imodel=0; imodel< gOptGenieInputs.NModels(); imodel++) {
       models.push_back(Model(iset,imodel));
  }
     
  if(models.size()==0 && !dbtable) return;


  int plots_per_page = kNCx * kNCy;
  int iplot = 1 + iset % plots_per_page;
  if(iplot == 1) {
     gPS->NewPage();
     gC -> Clear();
     gC -> Divide(kNCx,kNCy);
  }

  gC -> GetPad(iplot) -> Range(0,0,100,100);
  gC -> GetPad(iplot) -> SetFillColor(0);
  gC -> GetPad(iplot) -> SetBorderMode(0);
  gC -> GetPad(iplot) -> cd();

  double xmin = 0.0, scale_xmin = 0.5;
  double xmax = 0.0, scale_xmax = 1.2;
  double ymin = 0.0, scale_ymin = 0.4;
  double ymax = 0.0, scale_ymax = 1.2;

  TH1F * hframe = 0;
  bool have_frame = false;

  if(dbtable) {
    TGraphAsymmErrors * graph = dbtable->GetGraph("err","W2");
    xmin  = ( graph->GetX() )[TMath::LocMin(graph->GetN(),graph->GetX())];
    xmax  = ( graph->GetX() )[TMath::LocMax(graph->GetN(),graph->GetX())];
    ymin  = ( graph->GetY() )[TMath::LocMin(graph->GetN(),graph->GetY())];
    ymax  = ( graph->GetY() )[TMath::LocMax(graph->GetN(),graph->GetY())];
    hframe = (TH1F*) gC->GetPad(1)->DrawFrame(
        scale_xmin*xmin, scale_ymin*ymin, scale_xmax*xmax, scale_ymax*ymax);
    have_frame = true;

    MultiGraph * mgraph = dbtable->GetMultiGraph("err","v");
    for(unsigned int igraph = 0; igraph < mgraph->NGraphs(); igraph++) {
       Format(mgraph->GetGraph(igraph), 1,1,1,1,8,0.8);
       mgraph->GetGraph(igraph)->Draw("P");
    }
  }//dbtable?

  if(models.size()>0) {
    if(!have_frame) {
       xmin  = ( models[0]->GetX() )[TMath::LocMin(models[0]->GetN(),models[0]->GetX())];
       xmax  = ( models[0]->GetX() )[TMath::LocMax(models[0]->GetN(),models[0]->GetX())];
       ymin  = ( models[0]->GetY() )[TMath::LocMin(models[0]->GetN(),models[0]->GetY())];
       ymax  = ( models[0]->GetY() )[TMath::LocMax(models[0]->GetN(),models[0]->GetY())];
       hframe = (TH1F*) gC->GetPad(1)->DrawFrame(
         scale_xmin*xmin, scale_ymin*ymin, scale_xmax*xmax, scale_ymax*ymax);
    }
    for(int imodel=0; imodel<gOptGenieInputs.NModels(); imodel++) {
       TGraph * plot = models[imodel];
       if(plot) {
         int lsty = kLStyle[imodel];
         Format(plot,1,lsty,2,1,1,1);
         plot->Draw("L");
       }
    }
  }

  //hframe->Draw();
  hframe->GetXaxis()->SetTitle("v (GeV)");
  hframe->GetYaxis()->SetTitle("d^{2}#sigma / d#Omega dE^{'} (nb/sr/GeV)");

  // title
  TLatex * title = new TLatex(
     scale_ymin*xmin,1.01*scale_ymax*ymax,kElXSecDataSetLabel[iset]);
  title->SetTextSize(0.04);
  title->Draw();

  gC->GetPad(iplot)->Update();
  gC->Update();
}
//_________________________________________________________________________________
// Formatting
//.................................................................................
void SetStyle(void)
{
  gROOT->SetStyle("Plain");
  
  gStyle -> SetPadTickX (1);
  gStyle -> SetPadTickY (1);
  
  // Turn off all borders
  //
  gStyle -> SetCanvasBorderMode (0);
  gStyle -> SetFrameBorderMode  (0);
  gStyle -> SetPadBorderMode    (0);
  gStyle -> SetDrawBorder       (0);
  gStyle -> SetCanvasBorderSize (0);
  gStyle -> SetFrameBorderSize  (0);
  gStyle -> SetPadBorderSize    (0);
  gStyle -> SetTitleBorderSize  (0);
  
  // Set the size of the default canvas
  //
  gStyle -> SetCanvasDefH (600);
  gStyle -> SetCanvasDefW (730);
  gStyle -> SetCanvasDefX  (10);
  gStyle -> SetCanvasDefY  (10);
  
  // Set marker style
  //
  gStyle -> SetMarkerStyle (20);
  gStyle -> SetMarkerSize   (1);
            
  // Set line widths
  //
  gStyle -> SetFrameLineWidth (1);
  gStyle -> SetFuncWidth      (2);
  gStyle -> SetHistLineWidth  (3);
  gStyle -> SetFuncColor      (2);
  gStyle -> SetFuncWidth      (3);
  
  // Set margins
  //     
  gStyle -> SetPadTopMargin    (0.10);
  gStyle -> SetPadBottomMargin (0.20);
  gStyle -> SetPadLeftMargin   (0.15);
  gStyle -> SetPadRightMargin  (0.03);
   
  // Set tick marks and turn off grids
  //
  gStyle -> SetNdivisions (505,"xyz");
      
  // Adjust size and placement of axis labels
  //                                                                             
  gStyle -> SetLabelSize   (0.040,  "xyz");
  gStyle -> SetLabelOffset (0.005,  "x"  );
  gStyle -> SetLabelOffset (0.005,  "y"  );
  gStyle -> SetLabelOffset (0.005,  "z"  );
  gStyle -> SetTitleSize   (0.060,  "xyz");
  gStyle -> SetTitleOffset (1.200,  "xz" );
  gStyle -> SetTitleOffset (1.000,  "y"  );

  // Set Data/Stat/... and other options
  //
  gStyle -> SetOptDate          (0);
  gStyle -> SetOptFile          (0);
  gStyle -> SetOptStat          (0);
  gStyle -> SetStatFormat       ("6.2f");
  gStyle -> SetFitFormat        ("8.4f");
  gStyle -> SetOptFit           (1);
  gStyle -> SetStatH            (0.20);
  gStyle -> SetStatStyle        (0);
  gStyle -> SetStatW            (0.30);
  gStyle -> SetStatX            (0.845);
  gStyle -> SetStatY            (0.845);
  gStyle -> SetOptTitle         (0);
  gStyle -> SetTitleX           (0.15);
  gStyle -> SetTitleW           (0.75);
  gStyle -> SetTitleY           (0.90);
  gStyle -> SetPalette          (1);
  gStyle -> SetLegendBorderSize (0);

  // Set paper size for life in the US or EU
  //
  gStyle -> SetPaperSize (TStyle::kA4);       //<-- tartes aux fraises
//gStyle -> SetPaperSize (TStyle::kUSLetter); //<-- donuts
}
//_________________________________________________________________________________
void Format(
    TGraph* gr, int lcol, int lsty, int lwid, int mcol, int msty, double msiz)
{
  if(!gr) return;

  if (lcol >= 0) gr -> SetLineColor   (lcol);
  if (lsty >= 0) gr -> SetLineStyle   (lsty);
  if (lwid >= 0) gr -> SetLineWidth   (lwid);

  if (mcol >= 0) gr -> SetMarkerColor (mcol);
  if (msty >= 0) gr -> SetMarkerStyle (msty);
  if (msiz >= 0) gr -> SetMarkerSize  (msiz);
}
//_________________________________________________________________________________
// Parsing command-line arguments, check/form filenames, etc
//.................................................................................
void GetCommandLineArgs(int argc, char ** argv)
{
  LOG("gvldtest", pNOTICE) << "*** Parsing command line arguments";

  gCmpWithData = true;

  // get GENIE inputs
  try {
     string inputs = utils::clap::CmdLineArgAsString(argc,argv,'g');
     bool ok = gOptGenieInputs.LoadFromFile(inputs);
     if(!ok) {
        LOG("gvldtest", pFATAL) << "Could not read: " << inputs;
        exit(1);
     }
  } catch(exceptions::CmdLineArgParserException e) {
     if(!e.ArgumentFound()) {
     }
  }
      
  // get DB URL
  try {
     gOptDbURL = utils::clap::CmdLineArgAsString(argc,argv,'h');
  } catch(exceptions::CmdLineArgParserException e) {
     if(!e.ArgumentFound()) {
       gOptDbURL = kDefDbURL;
     }
  }

  // get DB username
  try {
     gOptDbUser = utils::clap::CmdLineArgAsString(argc,argv,'u');
  } catch(exceptions::CmdLineArgParserException e) {
     if(!e.ArgumentFound()) {
       gCmpWithData = false;
     }
  }

  // get DB passwd
  try {
     gOptDbPasswd = utils::clap::CmdLineArgAsString(argc,argv,'p');
  } catch(exceptions::CmdLineArgParserException e) {
     if(!e.ArgumentFound()) {
       gCmpWithData = false;
     }
  }

}
//_________________________________________________________________________________
void PrintSyntax(void)
{
  LOG("gvldtest", pNOTICE)
    << "\n\n" << "Syntax:" << "\n"
    << "   gvld_nuxsec_vs_world_data [-h host] [-u user] [-p passwd] [-m model]\n";
}
//_________________________________________________________________________________

