//____________________________________________________________________________
/*!

\program gT2Kevgen

\brief   A GENIE event generation driver 'customized' for T2K.

         This driver can handle the JPARC neutrino flux files generated by
         jnubeam and use the realistic detector geometries / target mix of
         T2K detectors. It can be used for full-blown GENIE event generation
         in nd280, 2km and SuperK.

         T2K users should note that the generic GENIE event generation driver
         (gevgen) may still be a more appropriate tool to use for the simpler      
         event generation cases required for many 4-vector level / systematic
         studies - Please see the GENIE documentation (http://www.genie-mc.org)
         and contact me <C.V.Andreopoulos@rl.ac.uk> if in doubt.

         Syntax :

           gT2Kevgen [-h] [-r run#] 
                     -f flux -g geometry 
                     [-n flux_normalization] [-c ntimes_to_recycle_flux]
                     [-v geo_top_volume_name] [-p geo_maxpl_xml_file]
                     [-L geo_length_units] [-D geo_density_units]
                     <[-m max_nev]>

         Options :

           [] Denotes an optional argument

           <> Denotes test-mode arguments / don't use in physics production jobs

           -h Prints out the gT2Kevgen syntax and exits

           -r Specifies the MC run number [default: 1000]

           -g Input 'geometry'.
              This option can be used to specify any of:
              1 > A ROOT file containing a ROOT/GEANT geometry description
                  [Note] 
                  - This is the standard option for generating events in the
                    nd280, 2km and INGRID detectors.
                  [Examples] 
		  - To use the master volume from the ROOT geometry stored 
                    in the nd280-geom.root file, type:
                    '-g /some/path/nd280-geom.root'
              2 > A mix of target materials, each with its corresponding weight,
                  typed as a comma-separated list of nuclear pdg codes (in the
                  std PDG2006 convention: 10LZZZAAAI) with the weight fractions
                  in brackets, eg code1[fraction1],code2[fraction2],...
                  If that option is used (no detailed input geometry description) 
                  then the interaction vertices are distributed in the detector
                  by the detector MC.
                  [Note]                   
                  - This is the standard option for generating events in the
                    SuperK detector.
                  [Examples] 
                  - To use a target mix of 95% O16 and 5% H type:
                    '-g 1000080160[0.95],1000010010[0.05]'
		  - To use a target which is 100% C12, type:
                    '-g 1000060120'

           -v Input event generation volume - 
              can be used to force event generation in given sub-detector
              [default: the 'master/top volume' of the input geometry]

	   -p An XML file (generated by gmxpl) with the max (density weighted) 
              path-lengths for each target material in the input ROOT geometry.              
              If no file is input, then the geometry will be scanned at MC job 
              initialization to determine those max path lengths. 
              Supplying this file can speed-up the MC job initialization. 

           -L Input eometry length units 
              [default: mm]

           -D Input eometry density units 
              [default: gr_cm3]

           -f Input 'neutrino flux'.
              This option can be used to specify any of:
              1 > A T2K / jnubeam beam simulation output file and the detector 
                  location to be used.
                  The general sytax is:
                      -f /full/path/flux_file.root,detector_location
                  [Notes] 
                  - For more information on the flux ntuples, see (T2K internal):  
                    http://jnusrv01.kek.jp/internal/t2k/nubeam/flux/
                  - The detector location can be any of 'sk' or the near detector
                    positions 'nd1',...,'nd6' simulated in jnubeam.
                    See the above jnubeam web page for more info.
                  - The original hbook ntuples need to be converted to a ROOT 
                    format using the h2root ROOT utility.   
                  - The jnubeam flux ntuples are read via GENIE's GJPARCNuFlux 
                    driver. This customized GENIE event generation driver 
                    passes-through the complete JPARC input flux information 
                    (eg parent decay kinematics / position etc) for each neutrino 
                    event it generates (an additional 'flux' branch is added at 
                    the output event tree).
                  [Examples] 
                  - To use the SuperK flux ntuple from the flux.root file, 
                    type:
                       '-f /path/flux.root,sk'
                  - To use the 2km flux ntuple [near detector position 'nd1'
                    in the jnubeam flux simulation] from the flux.root file, 
                    type:
                       '-f /path/flux.root,nd1'
                  - To use the nd280 flux ntuple [near detector position 'nd5' 
                    in the jnubeam flux simulation] from the flux.root file, 
                    type:
                       '-f /path/flux.root,nd5'
              2 > A set of histograms stored in a ROOT file.
                  The general syntax is:
                      -f /path/histogram_file.root,neutrino_code[histo_name],...
                  [Notes] 
                  - The neutrino codes are the PDG ones:
                    nu_e     ->  12, nu_mu     ->  14, nu_tau     ->  16,
                    nu_e_bar -> -12, nu_mu_bar -> -14, nu_tau_bar -> -16
                  - The 'neutrino_code[histogram_name]' part of the option can be 
                    repeated multiple times (separated by commas), once for each 
                    flux neutrino species you want to consider, eg
                    '-f somefile.root,12[nuehst],-12[nuebarhst],14[numuhst]'
                  - When using flux from histograms you must specify the -m option
                    as well (number of events to generate) as there is no other way
                    to determine when the MC job should finish. The POT normalization
                    for that sample should be worked out independently. In contrast, 
                    when using the jnubeam flux ntuples as inputs, the MC job stops
                    when it reaches the end of the flux ntuple (or after it has 
                    recycled that ntuple for a predefined number of times). In that
                    later case, the POT normalization is worked out at the end of the
                    MC job and saved at the output file, but the actual number of 
                    events in that file is not defined in advance (depends on the 
                    flux weights, interaction prob scale etc...).                    
                    That distinction is an important distinction between the two 
                    different ways of specifying a neutrino flux.
                  - When using flux from histograms then there is no point in using
                    a 'detailed detector geometry description' as your flux input
                    contains no directional information for those flux neutrinos.
                    The neutrino direction is conventionally set to be +z {x=0,y=0}.
                    So, when using this option you must be using a simple 'target mix'
                    See the -g option for possible geometry settings.
                    If you want to use the detailed detector geometry description
                    then you should be feeding this driver with the jnubeam flux 
                    simulation outputs.
                  - When using flux from histograms there is no branch with neutrino
                    parent information (code, decay mode, 4-momentum at prod & decay)
                    added in the output event tree as your flux input contains no
                    such information. If you want to be getting the neutrino parent
                    information written out as well then you should be feeding this
                    driver with the jnubeam flux simulation outputs.
                  - Note that the relative normalization of the flux histograms is
                    taken into account and is reflected in the relative frequency 
                    of flux neutrinos thrown by the flux driver
                  [Examples] 
                  - To use the histogram 'h100' (representing the nu_mu flux) and
                    the histogram 'h300' (representing the nu_e flux) and the 
                    histogram 'h301' (representing the nu_e_bar flux( from the
                    flux.root file in /path/ 
                    type:
                      '-f /path/flux.root,14[h100],12[h300],-12[h301]
                  
           -n Input neutrino flux normalization.
              [default: The 'standard' T2K/jnubeam flux ntuple normalization of 
               1E+21 POT/detector for the near detectors and
               1E+21 POT/cm2 for the far detector]
              That will be used to calculate the actual normalization for the
              generated sample.

           -c Specifies how many times to cycle a jnubeam flux ntuple.
              [default: 1]
              Due to the large rejection factor when generating unweighted events
              in the full energy range (approximately ~500 flux neutrinos will be 
              rejected before getting an interaction in nd280), an option is
              provided to recycle the flux ntuples for a number of times.
              That option can be used to boost the generated statistics without
              requiring enormous flux files.

           -m The driver will normally keep on generating events till _all_ the 
              flux neutrinos in the input flux tree have been 'thrown' towards
              the detector. The number of simulated neutrino interactions 
              depends on the input flux tree size. Set this option if you want
              the event generation to stop after generating a fixed number of
              interactions.

         Examples:
        
         (1) shell% gT2Kevgen 
                       -r 2001 
                       -f /data/t2k/flux/07a/jnubeam001.root,nd5
                       -g /data/t2k/geom/nd280.root -L mm -D g_cm3

             <description>

         (2) shell% gT2Kevgen 
                      -r 1001 
                      -f /data/t2k/flux/07a/jnubeam001.root,sk
                      -g 1000080160[0.95],1000010010[0.05]

             <description>

         (3) shell% gT2Kevgen 
                       -r 1001 
                       -f /data/t2k/flux/hst/flux.root,12[h100],-12[h101],14[h200]
                       -g 1000080160[0.95],1000010010[0.05]

             <description>

         You can further control the GENIE behaviour by setting its standard 
         environmental variables, more importantly
          - GEVGL        --> specifies which event generation threads are loaded
          - GSPLOAD      --> specifies the XML cross section table is loaded at init
          - GSEED        --> specifies the GENIE seed
          - GMSGCONF     --> overrides default mesg thresholds 
          - GUSERPHYSOPT --> overrides default table of user physics params.
         and others. 
         Please read the GENIE documentation.

\author  Costas Andreopoulos <C.V.Andreopoulos@rl.ac.uk>
         STFC, Rutherford Appleton Laboratory

\created February 05, 2008

\cpright Copyright (c) 2003-2008, GENIE Neutrino MC Generator Collaboration
         For the full text of the license visit http://copyright.genie-mc.org
         or see $GENIE/LICENSE
*/
//____________________________________________________________________________

#include <cassert>
#include <cstdlib>
#include <string>
#include <sstream>
#include <vector>
#include <map>

#include <TSystem.h>
#include <TTree.h>
#include <TFile.h>
#include <TH1D.h>
#include <TGeoVolume.h>
#include <TGeoShape.h>

#include "Conventions/Units.h"
#include "EVGCore/EventRecord.h"
#include "EVGDrivers/GFluxI.h"
#include "EVGDrivers/GMCJDriver.h"
#include "EVGDrivers/GMCJMonitor.h"
#include "Messenger/Messenger.h"
#include "Ntuple/NtpWriter.h"
#include "PDG/PDGLibrary.h"
#include "PDG/PDGCodes.h"
#include "Ntuple/NtpMCFormat.h"
#include "Utils/XSecSplineList.h"
#include "Utils/StringUtils.h"
#include "Utils/UnitUtils.h"
#include "Utils/CmdLineArgParserUtils.h"
#include "Utils/CmdLineArgParserException.h"

#ifdef __GENIE_FLUX_DRIVERS_ENABLED__
#include "FluxDrivers/GJPARCNuFlux.h"
#include "FluxDrivers/GCylindTH1Flux.h"
#endif

#ifdef __GENIE_GEOM_DRIVERS_ENABLED__
#include "Geo/ROOTGeomAnalyzer.h"
#include "Geo/PointGeomAnalyzer.h"
#endif

using std::string;
using std::vector;
using std::map;
using std::ostringstream;

using namespace genie;

void GetCommandLineArgs (int argc, char ** argv);
void PrintSyntax        (void);

// Default options (override them using the command line arguments):
//
Long_t          kDefOptRunNu       = 0;       // default run number
string          kDefOptGeomLUnits  = "mm";    // default geometry length units
string          kDefOptGeomDUnits  = "g_cm3"; // default geometry density units
NtpMCFormat_t   kDefOptNtpFormat   = kNFGHEP; // default event tree format
Long_t          kDefOptMaxNev      = -1;      // 
double          kDefOptFluxNorm    = 1E+21;   // std jnubeam flux ntuple norm. (POT*detector [NDs] or POT*cm^2 [SK])
int             kDefOptFluxNCycles = 1;       // default number of flux ntuple cycles

// User-specified options:
//
Long_t          gOptRunNu;                    // run number
bool            gOptUsingRootGeom = false;    // using root geom or target mix?
bool            gOptUsingHistFlux = false;    // using jnubeam flux ntuples or flux from histograms?
map<int,double> gOptTgtMix;                   // target mix  (tgt pdg -> wght frac) / if not using detailed root geom
map<int,TH1D*>  gOptFluxHst;                  // flux histos (nu pdg  -> spectrum)  / if not using beam sim ntuples
string          gOptRootGeom;                 // input ROOT file with realistic detector geometry
string          gOptRootGeomTopVol = "";      // input geometry top event generation volume [optional]
double          gOptGeomLUnits = 0;           // input geometry length units [optional]
double          gOptGeomDUnits = 0;           // input geometry density units [optional]
string          gOptExtMaxPlXml;              // max path lengths XML file for input geometry [optional]
string          gOptFluxFile;                 // ROOT file with jnubeam flux ntuple
string          gOptDetectorLocation;         // detector location ('sk','nd1','nd2',...)
int             gOptMaxNev;                   // 
double          gOptFluxNorm;                 // std jnubeam flux ntuple norm
int             gOptFluxNCycles;              // number of flux ntuple cycles

//____________________________________________________________________________
int main(int argc, char ** argv)
{
  // Parse command line arguments
  GetCommandLineArgs(argc,argv);
  
  // Autoload splines (from the XML file pointed at the $GSPLOAD env. var.,
  // if the env. var. has been set)
  //XSecSplineList * xspl = XSecSplineList::Instance();
  //xspl->AutoLoad();

  // *************************************************************************
  // * Create / configure the geometry driver 
  // *************************************************************************
  GeomAnalyzerI * geom_driver = 0;
  double zmin=0, zmax=0;

  if(gOptUsingRootGeom) {
    //
    // *** Using a realistic root-based detector geometry description 
    //

    // creating & configuring a root geometry driver
    geometry::ROOTGeomAnalyzer * rgeom = 
            new geometry::ROOTGeomAnalyzer(gOptRootGeom);
    rgeom -> SetLengthUnits  (gOptGeomLUnits);
    rgeom -> SetDensityUnits (gOptGeomDUnits);
    rgeom -> SetTopVolName   (gOptRootGeomTopVol);
    // getting the bounding box dimensions along z so as to set the
    // appropriate upstream generation surface for the JPARC flux driver
    TGeoVolume * topvol = rgeom->GetGeometry()->GetTopVolume();
    if(!topvol) {
      LOG("gT2Kevgen", pFATAL) << "Null top ROOT geometry volume!";
      exit(1);
    }
    TGeoShape * bounding_box = topvol->GetShape();
    bounding_box->GetAxisRange(3, zmin, zmax);
    zmin *= rgeom->LengthUnits();
    zmax *= rgeom->LengthUnits();
    // casting to the GENIE geometry driver interface
    geom_driver = dynamic_cast<GeomAnalyzerI *> (rgeom);
  } 
  else {
    //
    // *** Using a 'point' geometry with the specified target mix 
    // *** ( = a list of targets with their corresponding weight fraction)
    //
 
    // creating & configuring a point geometry driver
    geometry::PointGeomAnalyzer * pgeom = 
  	      new geometry::PointGeomAnalyzer(gOptTgtMix);
    // casting to the GENIE geometry driver interface
    geom_driver = dynamic_cast<GeomAnalyzerI *> (pgeom);
  } 

  // *************************************************************************
  // * Create / configure the flux driver 
  // *************************************************************************
  GFluxI * flux_driver = 0;

  flux::GJPARCNuFlux *   jparc_flux_driver = 0;
  flux::GCylindTH1Flux * hst_flux_driver   = 0;

  if(!gOptUsingHistFlux) {
    //
    // *** Using the detailed JPARC neutrino flux desription by feeding-in 
    // *** the jnubeam flux simulation ntuples
    //

    // creating & configuring a JPARC neutrino flux driver
    jparc_flux_driver = new flux::GJPARCNuFlux;
    jparc_flux_driver->LoadBeamSimData(gOptFluxFile, gOptDetectorLocation);
    jparc_flux_driver->SetFilePOT(gOptFluxNorm);
    jparc_flux_driver->SetNumOfCycles(gOptFluxNCycles);
    jparc_flux_driver->SetUpstreamZ(zmin);
    // casting to the GENIE flux driver interface
    flux_driver = dynamic_cast<GFluxI *> (jparc_flux_driver);
  } 
  else {
    //
    // *** Using fluxes from histograms (for all specified neutrino species)
    //

    // creating & configuring a generic GCylindTH1Flux flux driver
    TVector3 bdir (0,0,1); // dir along +z
    TVector3 bspot(0,0,0);
    hst_flux_driver = new flux::GCylindTH1Flux;
    hst_flux_driver->SetNuDirection      (bdir);
    hst_flux_driver->SetBeamSpot         (bspot);
    hst_flux_driver->SetTransverseRadius (-1);
    map<int,TH1D*>::iterator it = gOptFluxHst.begin();
    for( ; it != gOptFluxHst.end(); ++it) {
        int    pdg_code = it->first;
        TH1D * spectrum = it->second;
        hst_flux_driver->AddEnergySpectrum(pdg_code, spectrum);
    }
    // casting to the GENIE flux driver interface
    flux_driver = dynamic_cast<GFluxI *> (hst_flux_driver);
  }

  // *************************************************************************
  // * Create/configure the event generation driver 
  // *************************************************************************
  GMCJDriver * mcj_driver = new GMCJDriver;
  mcj_driver->UseFluxDriver(flux_driver);    
  mcj_driver->UseGeomAnalyzer(geom_driver);        
  mcj_driver->UseMaxPathLengths(gOptExtMaxPlXml);  
  mcj_driver->Configure();                         
  mcj_driver->UseSplines();        
  mcj_driver->ForceSingleProbScale();

  // *************************************************************************
  // * Prepare for writing the output event tree & status file
  // *************************************************************************

  // Initialize an Ntuple Writer to save GHEP records into a TTree
  NtpWriter ntpw(kDefOptNtpFormat, gOptRunNu);
  ntpw.Initialize();

  // Add a custom-branch at the standard GENIE event tree so that
  // info on the flux neutrino parent particle can be passed-through
  flux::GJPARCNuFluxPassThroughInfo * flux_info = 0;
  if(!gOptUsingHistFlux) {
    TBranch * flux = ntpw.EventTree()->Branch("flux",
       "genie::flux::GJPARCNuFluxPassThroughInfo", &flux_info, 32000, 1);
    assert(flux);
    flux->SetAutoDelete(kFALSE);
  }

  // Create a MC job monitor for a periodically updated status file
  GMCJMonitor mcjmonitor(gOptRunNu);

  // *************************************************************************
  // * Event generation loop
  // *************************************************************************

  int ievent = 0;
  while (1) 
  {
     LOG("gT2Kevgen", pNOTICE) 
          << " *** Generating event............ " << ievent;

     if(ievent==gOptMaxNev) break;

     // Generate a single event using neutrinos coming from the specified flux
     // and hitting the specified geometry or target mix
   
     EventRecord * event = mcj_driver->GenerateEvent();

     // Check whether a null event was returned due to the flux driver reaching
     // the end of the input flux ntuple - exit the event generation loop
     if(!event && jparc_flux_driver->End()) {
	LOG("gT2Kevgen", pNOTICE) 
           << "The JPARC flux driver read all the input flux ntuple entries.";
	break;
     }
     if(!event) {
  	 LOG("gT2Kevgen", pERROR) 
           << "Got a null generated neutino event!";
         continue;
     }
     LOG("gT2Kevgen", pINFO)  
         << "Generated event: " << *event;

     // A valid event was generated: extract flux info (parent decay/prod
     // position/kinematics) for that simulated event so that it can be 
     // passed-through.
     // Can only do so if I am generating events using the jnubeam flux
     // ntuples, not simple histograms
     if(!gOptUsingHistFlux) {
        flux_info = new flux::GJPARCNuFluxPassThroughInfo(
            jparc_flux_driver->PassThroughInfo());
        LOG("gT2Kevgen", pINFO) 
          << "Pass-through flux info associated with generated event: " 
          << *flux_info;
     }

     // Add event at the output ntuple, refresh the mc job monitor & clean-up
     ntpw.AddEventRecord(ievent, event);
     mcjmonitor.Update(ievent,event);
     delete event;

     ievent++;
  } //1

  LOG("gT2Kevgen", pNOTICE) 
    << "The GENIE MC job is done generaing events - Cleaning up & exiting...";

  // *************************************************************************
  // * Calculate normalization factor for the generated sample
  // *************************************************************************
  if(gOptMaxNev<0 && !gOptUsingHistFlux) 
  {
    // POT normalization will only be calculated if event generation was based
    // on beam simulation outputs (not just histograms) & if event generation
    // was not cut short (flux friver reached the end of flux ntuple)
    double fpot = jparc_flux_driver->ActualPOT(); // actual POT in flux file 
    double psc  = mcj_driver->GlobProbScale();    // interaction prob. scale 
    double pot  = fpot / psc;                     // POT for generated sample
    // Get nunber of flux neutrinos read-in by flux friver, number of flux
    // neutrinos actually thrown to the event generation driver and number
    // of neutrino interactions actually generated
    long int nflx_evg = mcj_driver        -> NFluxNeutrinos(); 
    long int nflx     = jparc_flux_driver -> NFluxNeutrinos();
    long int nev      = ievent;

    LOG("gT2Kevgen", pNOTICE) 
        << "\n >> Actual jnubeam flux file normalization:  " << fpot 
            << " POT * " << ((gOptDetectorLocation == "sk") ? "cm^2" : "det")
        << "\n >> Interaction probability scaling factor:  " << psc
        << "\n >> N of flux v read-in by flux driver:      " << nflx
        << "\n >> N of flux v thrown to event gen driver:  " << nflx_evg
        << "\n >> N of generated v interactions:           " << nev
        << "\n ** Normalization for generated sample:      " << pot 
            << " POT * " << ((gOptDetectorLocation == "sk") ? "cm^2" : "det");

    ntpw.EventTree()->SetWeight(pot); // POT
  }

  // *************************************************************************
  // * Save & clean-up
  // *************************************************************************

  // Save the generated event tree & close the output file
  ntpw.Save();

  // Clean-up
  delete geom_driver;
  delete jparc_flux_driver;
  delete mcj_driver;
  map<int,TH1D*>::iterator it = gOptFluxHst.begin();
  for( ; it != gOptFluxHst.end(); ++it) {
    TH1D * spectrum = it->second;
    if(spectrum) delete spectrum;
  }
  gOptFluxHst.clear();

  return 0;
}
//____________________________________________________________________________
void GetCommandLineArgs(int argc, char ** argv)
{
// get gT2Kevgen command line arguments

  // help?
  bool help = genie::utils::clap::CmdLineArgAsBool(argc,argv,'h');
  if(help) {
      PrintSyntax();
      exit(0);
  }

  LOG("gT2Kevgen", pNOTICE) << "Parsing command line arguments";

  // run number:
  try {
    LOG("gT2Kevgen", pDEBUG) << "Reading MC run number";
    gOptRunNu = genie::utils::clap::CmdLineArgAsInt(argc,argv,'r');
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("gT2Kevgen", pDEBUG) << "Unspecified run number - Using default";
      gOptRunNu = kDefOptRunNu;
    }
  }

  //
  // *** geometry
  //

  string geom = "";
  string lunits, dunits;
  try {
    LOG("Main", pDEBUG) << "Getting input geometry";
    geom = genie::utils::clap::CmdLineArgAsString(argc,argv,'g');

    // is it a ROOT file that contains a ROOT geometry?
    bool accessible_geom_file = 
            ! (gSystem->AccessPathName(geom.c_str()));
    if (accessible_geom_file) {
      gOptRootGeom      = geom;
      gOptUsingRootGeom = true;
    }                 
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("Main", pFATAL) 
        << "No geometry option specified - Exiting";
      PrintSyntax();
      exit(1);
    }
  }

  if(gOptUsingRootGeom) {
     // using a ROOT geometry - get requested geometry units

     // legth units:
     try {
        LOG("Main", pDEBUG) 
           << "Checking for input geometry length units";
        lunits = genie::utils::clap::CmdLineArgAsString(argc,argv,'L');
     } catch(exceptions::CmdLineArgParserException e) {
        if(!e.ArgumentFound()) {
            LOG("Main", pDEBUG) << "Using default geometry length units";
            lunits = kDefOptGeomLUnits;
        }
     } // try-catch (-L)
     // density units:
     try {
        LOG("Main", pDEBUG) 
           << "Checking for input geometry density units";
        dunits = genie::utils::clap::CmdLineArgAsString(argc,argv,'D');
     } catch(exceptions::CmdLineArgParserException e) {
        if(!e.ArgumentFound()) {
            LOG("Main", pDEBUG) << "Using default geometry density units";
            dunits = kDefOptGeomDUnits;
        }
     } // try-catch (-D) 
     gOptGeomLUnits = genie::utils::units::UnitFromString(lunits);
     gOptGeomDUnits = genie::utils::units::UnitFromString(dunits);

     // check whether an event generation volume name has been 
     // specified -- default is the 'top volume'
     try {
        LOG("Main", pDEBUG) << "Checking for input volume name";
        gOptRootGeomTopVol = 
            genie::utils::clap::CmdLineArgAsString(argc,argv,'v');
     } catch(exceptions::CmdLineArgParserException e) {
        if(!e.ArgumentFound()) {
            LOG("Main", pDEBUG) << "Using the <master volume>";
        }
     } // try-catch (-v) 

     // check whether an XML file with the maximum (density weighted)
     // path lengths for each detector material is specified -
     // otherwise will compute the max path lengths at job init
     try {
        LOG("Main", pDEBUG) 
              << "Checking for maximum path lengths XML file";
        gOptExtMaxPlXml = 
            genie::utils::clap::CmdLineArgAsString(argc,argv,'p');
     } catch(exceptions::CmdLineArgParserException e) {
        if(!e.ArgumentFound()) {
            LOG("Main", pDEBUG) 
              << "Will compute the maximum path lengths at job init";
            gOptExtMaxPlXml = "";
        }
     } // try-catch (-p) 
  } // using root geom?

  else {
    // User has specified a target mix.
    // Decode the list of target pdf codes & their corresponding weight fraction
    // (specified as 'pdg_code_1[fraction_1],pdg_code_2[fraction_2],...')
    // See documentation on top section of this file.
    //
    gOptTgtMix.clear();
    vector<string> tgtmix = utils::str::Split(geom,",");
    if(tgtmix.size()==1) {
         int    pdg = atoi(tgtmix[0].c_str());
         double wgt = 1.0;
         gOptTgtMix.insert(map<int, double>::value_type(pdg, wgt));    
    } else {
      vector<string>::const_iterator tgtmix_iter = tgtmix.begin();
      for( ; tgtmix_iter != tgtmix.end(); ++tgtmix_iter) {
   	 string tgt_with_wgt = *tgtmix_iter;
	 string::size_type open_bracket  = tgt_with_wgt.find("[");
	 string::size_type close_bracket = tgt_with_wgt.find("]");
         if (open_bracket ==string::npos || 
             close_bracket==string::npos) 
         {
             LOG("Main", pFATAL) 
                << "You made an error in specifying the target mix"; 
             PrintSyntax();
             exit(1);
         }
	 string::size_type ibeg = 0;
	 string::size_type iend = open_bracket;
	 string::size_type jbeg = open_bracket+1;
	 string::size_type jend = close_bracket;
         int    pdg = atoi(tgt_with_wgt.substr(ibeg,iend-ibeg).c_str());
         double wgt = atof(tgt_with_wgt.substr(jbeg,jend-jbeg).c_str());
         LOG("Main", pDEBUG) 
            << "Adding to target mix: pdg = " << pdg << ", wgt = " << wgt;
         gOptTgtMix.insert(map<int, double>::value_type(pdg, wgt));

      }// tgtmix_iter
    } // >1 materials in mix
  } // using tgt mix?

  //
  // *** flux 
  // 
  try {
    LOG("Main", pDEBUG) << "Getting input flux";
    string flux = genie::utils::clap::CmdLineArgAsString(argc,argv,'f');
    gOptUsingHistFlux = (flux.find("[") != string::npos);

    if(!gOptUsingHistFlux) {
        // Using jnubeam flux ntuples
        // Extract jnubeam flux (root) file name & detector location
        //
        vector<string> fluxv = utils::str::Split(flux,",");
        if(fluxv.size()<2) {
           LOG("Main", pFATAL) 
             << "You need to specify both a flux ntuple ROOT file " 
             << " _AND_ a detector location";
           PrintSyntax();
           exit(1);
        }
        gOptFluxFile         = fluxv[0];
        gOptDetectorLocation = fluxv[1];
    } else {
        // Using flux from histograms
        // Extract the root file name & the list of histogram names & neutrino 
        // species (specified as 'filename,histo1[species1],histo2[species2],...') 
        // See documentation on top section of this file.
        //
        vector<string> fluxv = utils::str::Split(flux,",");      
        if(fluxv.size()<2) {
           LOG("Main", pFATAL) 
             << "You need to specify both a flux ntuple ROOT file " 
             << " _AND_ a detector location";
           PrintSyntax();
           exit(1);
        }
        gOptFluxFile = fluxv[0];
        bool accessible_flux_file = !(gSystem->AccessPathName(gOptFluxFile.c_str()));
        if (!accessible_flux_file) {
            LOG("Main", pFATAL) 
              << "Can not access flux file: " << gOptFluxFile;
            PrintSyntax();
            exit(1);
        }
        // Extract energy spectra for all specified neutrino species
        TFile flux_file(gOptFluxFile.c_str(), "read");
        for(unsigned int inu=1; inu<fluxv.size(); inu++) {
            string nutype_and_histo = fluxv[inu];
   	    string::size_type open_bracket  = nutype_and_histo.find("[");
	    string::size_type close_bracket = nutype_and_histo.find("]");
            if (open_bracket ==string::npos || 
                close_bracket==string::npos) 
            {
                LOG("Main", pFATAL) 
                   << "You made an error in specifying the flux histograms"; 
                PrintSyntax();
                exit(1);
            }
   	    string::size_type ibeg = 0;
	    string::size_type iend = open_bracket;
	    string::size_type jbeg = open_bracket+1;
	    string::size_type jend = close_bracket;
            string nutype = nutype_and_histo.substr(ibeg,iend-ibeg);
            string histo  = nutype_and_histo.substr(jbeg,jend-jbeg);
            // access specified histogram from the input root file
            TH1D * ihst = (TH1D*) flux_file.Get(histo.c_str()); 
            if(!ihst) {
                LOG("Main", pFATAL) 
                  << "Can not find histogram: " << histo 
                  << " in flux file: " << gOptFluxFile;
                PrintSyntax();
                exit(1);
            }
            // create a local copy of the input histogram
            TH1D * spectrum = new TH1D(
                 histo.c_str(), histo.c_str(), ihst->GetNbinsX(),  
                 ihst->GetXaxis()->GetXmin(), ihst->GetXaxis()->GetXmax());
            spectrum->SetDirectory(0);
            for(int ibin = 1; ibin <= ihst->GetNbinsX(); ibin++) {
               spectrum->SetBinContent(ibin, ihst->GetBinContent(ibin));
            }
            // convert neutrino name -> pdg code
            int pdg = atoi(nutype.c_str());
            if(!pdg::IsNeutrino(pdg) && !pdg::IsAntiNeutrino(pdg)) {
                LOG("Main", pFATAL) 
                    << "Unknown neutrino type: " << nutype; 
                PrintSyntax();
                exit(1);
            }
            // store flux neutrino code / energy spectrum
            LOG("Main", pDEBUG) 
              << "Adding energy spectrum for flux neutrino: pdg = " << pdg;
            gOptFluxHst.insert(map<int, TH1D*>::value_type(pdg, spectrum));
        }//inu
        if(gOptFluxHst.size()<1) {
           LOG("Main", pFATAL) 
               << "You have not specified any flux histogram!";
           PrintSyntax();
           exit(1);
        }
        flux_file.Close();
    } // flux from histograms or from jnubeam ntuples?

  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("Main", pFATAL) << "No flux info was specified - Exiting";
      PrintSyntax();
      exit(1);
    }
  }


  // flux file normalization
  // only relevant when using the jnubeam flux ntuples
  try {
    LOG("gT2Kevgen", pDEBUG)  << "Reading flux file normalization";
    gOptFluxNorm = genie::utils::clap::CmdLineArgAsDouble(argc,argv,'n');
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("gT2Kevgen", pDEBUG)
        << "Setting standard normalization for jnubeam flux ntuples";
      gOptFluxNorm = kDefOptFluxNorm;
    }
  }

  // number of times to cycle through the jnubeam flux ntuple contents
  try {
    LOG("gT2Kevgen", pDEBUG)  << "Reading number of flux ntuple cycles";
    gOptFluxNCycles = genie::utils::clap::CmdLineArgAsDouble(argc,argv,'c');
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("gT2Kevgen", pDEBUG)
        << "Setting standard number of cycles for jnubeam flux ntuples";
      gOptFluxNCycles = kDefOptFluxNCycles;
    }
  }

  // limit on max number of events that can be generated
  try {
    LOG("gT2Kevgen", pDEBUG) 
        << "Reading limit on number of events to generate";
    gOptMaxNev = genie::utils::clap::CmdLineArgAsInt(argc,argv,'m');
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("gT2Kevgen", pDEBUG)
        << "Will keep on generating events till the flux driver stops";
      gOptMaxNev = kDefOptMaxNev;
    }
  }

  //
  // print the command line options
  //
  PDGLibrary * pdglib = PDGLibrary::Instance();

  ostringstream gminfo;
  if (gOptUsingRootGeom) {
    gminfo << "using ROOT geometry: file = " << gOptRootGeom 
           << ", top volume = " 
           << ((gOptRootGeomTopVol.size()==0) ? "<master volume>" : gOptRootGeomTopVol)
           << ", max{PL} file = " 
           << ((gOptExtMaxPlXml.size()==0) ? "<none>" : gOptExtMaxPlXml)
           << ", length  units  = " << lunits
           << ", density units  = " << dunits;
  } else {
    gminfo << "using target mix: ";
    map<int,double>::const_iterator iter;
    for(iter = gOptTgtMix.begin(); iter != gOptTgtMix.end(); ++iter) {
          int    pdg_code = iter->first;
          double wgt      = iter->second;
          TParticlePDG * p = pdglib->Find(pdg_code);
          if(p) {
            string name = p->GetName();
            gminfo << "(" << name << ") -> " << 100*wgt << "% / ";
          }//p?
    }
  }

  ostringstream fluxinfo;
  if(gOptUsingHistFlux) {
    fluxinfo << "using histograms: ";
    map<int,TH1D*>::const_iterator iter;
    for(iter = gOptFluxHst.begin(); iter != gOptFluxHst.end(); ++iter) {
          int    pdg_code = iter->first;
          TH1D * spectrum = iter->second;
          TParticlePDG * p = pdglib->Find(pdg_code);
          if(p) {
            string name = p->GetName();
            fluxinfo << "(" << name << ") -> " << spectrum->GetName() << " / ";
          }//p?
    }
  } else {
    fluxinfo << "using jnubeam simulation: "
             << "file = "        << gOptFluxFile
             << ", location = "  << gOptDetectorLocation
             << ", ncycles = "   << gOptFluxNCycles;
  }

  LOG("gT2Kevgen", pNOTICE) 
     << "\n MC Job (" << gOptRunNu << ") Settings: "
     << "\n - Flux     : " << fluxinfo.str()
     << "\n - Geometry : " << gminfo.str();
}
//____________________________________________________________________________
void PrintSyntax(void)
{
  string basedir  = string( gSystem->Getenv("GENIE") );
  string thisfile = basedir + string("/src/support/t2k/EvGen/gT2KEvGen.cxx");
  string cmd      = "more " + thisfile;

  gSystem->Exec(cmd.c_str());
}
//____________________________________________________________________________
