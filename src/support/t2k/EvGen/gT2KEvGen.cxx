//____________________________________________________________________________
/*!

\program gT2Kevgen

\brief   A GENIE event generation driver 'customized' for T2K.

         This driver can handle the JPARC neutrino flux files generated by
         jnubeam and use the realistic detector geometries / target mix of
         T2K detectors. It can be used for full-blown GENIE event generation
         in nd280, 2km and SuperK.

         T2K users should note that the generic GENIE event generation driver
         (gevgen) may still be a more appropriate tool to use for the simpler      
         event generation cases required for many 4-vector level / systematic
         studies - Please see the GENIE documentation (http://www.genie-mc.org)
         and contact me <C.V.Andreopoulos@rl.ac.uk> if in doubt.

         Syntax :
           gT2Kevgen [-h] [-r run#] -d detector -f flux -g geometry
                     [-v geo_top_volume_name] [-p geo_maxpl_xml_file]
                     [-L geo_length_units] [-D geo_density_units]
                     <[-n nev_max]>

         Options :
           [] Denotes an optional argument
           <> Denotes test-mode arguments / don't use in physics production jobs
           -h Prints out the gT2Kevgen syntax and exits
           -r Specifies the MC run number (def: 1000)
           -d detector (0: nd280, 1: 2km, 2: SK)
           -g geometry
                This can be used to specify any of:
                * A ROOT file containing a ROOT/GEANT geometry description
                  Examples: 
		     >> to use the master volume from the ROOT geometry stored 
                        in the nd280-geom.root file, type:
                        '-g /some/path/nd280-geom.root'
                  [Note] 
                     This is the standard option for generating events in the
                     nd280 and the 2km detectors.
                * A mix of target materials, each with its corresponding weight,
                  typed as a comma-separated list of nuclear pdg codes (in the
                  std PDG2006 convention: 10LZZZAAAI) with the weight fractions
                  in brackets, eg code1[fraction1],code2[fraction2],...
                  If that option is used (no detailed input geometry description) 
                  then the interaction vertices are distributed in the detector
                  by the detector mc.
                  Examples: 
                     >> to use a target mix of 95% O16 and 5% H type:
                        '-g 1000080160[0.95],1000010010[0.05]'
		     >> to use a target which is 100% C12, type:
                        '-g 1000060120'
                  [Note]                   
                     This is the standard option for generating events in the
                     SuperK detector.
           -v event generation volume - can be used to force event generation
              in given sub-detector
              [default: the 'master/top volume' of the input geometry]
	   -p an XML file (generated by gmxpl) with the max (density weighted) 
              path lengths for each target material in the input ROOT geometry.
              If no file is input, then the geometry will be scanned at MC job 
              initialization to determine those max path lengths. Supplying this
              file can speed-up the MC job initialization. 
           -L geometry length  units 
              [default: mm]
           -D geometry density units 
              [default: gr_cm3]
           -f flux 
                This can be used to specify any of:
   	        * A ROOT file with a flux neutrino ntuple generated by the T2K 
                  (jnubeam) beam simulation. See (T2K internal):  
                  See: http://jnusrv01.kek.jp/internal/t2k/nubeam/flux/
                  The original hbook ntuples need to be converted to a ROOT 
                  format using the h2root ROOT utility.   
                  The jnubeam flux ntuples are read via GENIE's GJPARCNuFlux 
                  driver. GENIE passes-through the complete input flux 
                  information (eg parent decay kinematics / position etc) for 
                  each neutrino event it generates (an additional 'flux' branch
                  is added at the output event tree).
                * 
           -n The driver will normally keep on generating events till _all_ the 
              flux neutrinos in the input flux tree have been 'thrown' towards
              the detector. The number of simulated neutrino interactions 
              depends on the input flux tree size. Set this option if you want
              the event generation to stop after generating a fixed number of
              interactions.

         Examples:
        
         (1) shell% gT2Kevgen -r 1001 -d 0 -f /data/t2k/flux/08a/nubeam001.root
                              -g /data/t2k/geom/nd280.root -L mm -D g_cm3

             <description>

         (2) shell% gT2Kevgen -r 1001 -d 2 -f /data/t2k/flux/08a/nubeam001.root
                              -g 1000080160[0.95],1000010010[0.05]

             <description>

         (3)
             <more examples to be added>

         You can further control the GENIE behaviour by setting its standard 
         environmental variables, more importantly
          - GEVGL        --> specifies which event generation threads are loaded
          - GSPLOAD      --> specifies the XML cross section table is loaded at init
          - GSEED        --> specifies the GENIE seed
          - GMSGCONF     --> overrides default mesg thresholds 
          - GUSERPHYSOPT --> overrides default table of user physics params.
         and others. 
         Please read the GENIE documentation.

\author  Costas Andreopoulos <C.V.Andreopoulos@rl.ac.uk>
         STFC, Rutherford Appleton Laboratory

\created February 05, 2008

\cpright Copyright (c) 2003-2008, GENIE Neutrino MC Generator Collaboration
         For the full text of the license visit http://copyright.genie-mc.org
         or see $GENIE/LICENSE
*/
//____________________________________________________________________________

#include <cassert>
#include <string>
#include <sstream>
#include <vector>
#include <map>

#include <TSystem.h>
#include <TTree.h>

#include "Conventions/Units.h"
#include "EVGCore/EventRecord.h"
#include "EVGDrivers/GFluxI.h"
#include "EVGDrivers/GMCJDriver.h"
#include "EVGDrivers/GMCJMonitor.h"
#include "Messenger/Messenger.h"
#include "Ntuple/NtpWriter.h"
#include "PDG/PDGLibrary.h"
#include "Ntuple/NtpMCFormat.h"
#include "Utils/XSecSplineList.h"
#include "Utils/StringUtils.h"
#include "Utils/UnitUtils.h"
#include "Utils/CmdLineArgParserUtils.h"
#include "Utils/CmdLineArgParserException.h"

#ifdef __GENIE_FLUX_DRIVERS_ENABLED__
#include "FluxDrivers/GJPARCNuFlux.h"
#endif

#ifdef __GENIE_GEOM_DRIVERS_ENABLED__
#include "Geo/ROOTGeomAnalyzer.h"
#include "Geo/PointGeomAnalyzer.h"
#endif

using std::string;
using std::vector;
using std::map;
using std::ostringstream;

using namespace genie;

void GetCommandLineArgs (int argc, char ** argv);
void PrintSyntax        (void);

// Default options (override them using the command line arguments):
//
Long_t        kDefOptRunNu      = 0;        // default run number
string        kDefOptGeomLUnits = "mm";     // default geometry length units
string        kDefOptGeomDUnits = "g_cm3";  // default geometry density units
NtpMCFormat_t kDefOptNtpFormat  = kNFGHEP;  // default event tree format
Long_t        kDefOptMaxNev     = -1;       // 

// User-specified options:
//
Long_t          gOptRunNu;                  // run number
bool            gOptUsingRootGeom  = false; //
bool            gOptUsingJPARCFlux = false; //
string          gOptRootGeom;               // detector geometry ROOT file
string          gOptRootGeomTopVol = "";    //
double          gOptGeomLUnits = 0;         //
double          gOptGeomDUnits = 0;         //
map<int,double> gOptTgtMix;                 //
string          gOptExtMaxPlXml;            // external max path lengths XML file
string          gOptFluxFile;               // flux file
int             gOptMaxNev;                 // 

//____________________________________________________________________________
int main(int argc, char ** argv)
{
  // Parse command line arguments
  GetCommandLineArgs(argc,argv);
  
  // Autoload splines (from the XML file pointed at the $GSPLOAD env. var.,
  // if the env. var. has been set)
  //XSecSplineList * xspl = XSecSplineList::Instance();
  //xspl->AutoLoad();

  //
  // *** Create/configure the flux driver
  //
  flux::GJPARCNuFlux * jparc_flux_driver = new flux::GJPARCNuFlux;
  jparc_flux_driver->LoadFile(gOptFluxFile);

  //
  // *** Create/configure the geometry driver
  //
  GeomAnalyzerI * geom_driver = 0;

  if(gOptUsingRootGeom) {
      // using a realistic root geometry
      geometry::ROOTGeomAnalyzer * rgeom = 
             new geometry::ROOTGeomAnalyzer(gOptRootGeom);
      rgeom -> SetLengthUnits  (gOptGeomLUnits);
      rgeom -> SetDensityUnits (gOptGeomDUnits);
      rgeom -> SetTopVolName   (gOptRootGeomTopVol);

      geom_driver = dynamic_cast<GeomAnalyzerI *> (rgeom);
  } 
  else {
      // using a 'point' geometry with the specified
      // target mix
      geometry::PointGeomAnalyzer * pgeom = 
  	      new geometry::PointGeomAnalyzer(gOptTgtMix);
      geom_driver = dynamic_cast<GeomAnalyzerI *> (pgeom);
  } 

  //
  // *** Create/configure the event generation driver
  //
  GMCJDriver * mcj_driver = new GMCJDriver;
  mcj_driver->UseFluxDriver(jparc_flux_driver);
  mcj_driver->UseGeomAnalyzer(geom_driver);
  mcj_driver->UseMaxPathLengths(gOptExtMaxPlXml);
  mcj_driver->Configure();
  mcj_driver->UseSplines();
  mcj_driver->ForceSingleProbScale();

  // Initialize an Ntuple Writer to save GHEP records into a TTree
  NtpWriter ntpw(kDefOptNtpFormat, gOptRunNu);
  ntpw.Initialize();

  // Add a custom-branch at the standard GENIE event tree so that
  // info on the flux neutrino parent particle can be passed-through
  flux::GJPARCNuFluxPassThroughInfo * flux_info = 0;
  TBranch * flux = ntpw.EventTree()->Branch("flux",
    "genie::flux::GJPARCNuFluxPassThroughInfo", &flux_info, 32000, 1);
  assert(flux);
  flux->SetAutoDelete(kFALSE);

  // Create a MC job monitor for a periodically updated status file
  GMCJMonitor mcjmonitor(gOptRunNu);

  // Generate events / print the GHEP record / add it to the ntuple
  int ievent = 0;
  while (1) {
     LOG("gT2Kevgen", pNOTICE) 
          << " *** Generating event............ " << ievent;

     if(ievent==gOptMaxNev) break;

     // generate a single event using neutrinos coming from the specified flux
     // and hitting the specified geometry or target mix
     EventRecord * event = mcj_driver->GenerateEvent();

     // check whether a null event was returned due to the flux driver reaching
     // the end of the input flux ntuple - exit the event generation loop
     if(!event && jparc_flux_driver->End()) {
	LOG("gT2Kevgen", pNOTICE) 
           << "";
	break;
     }

     if(!event) {
  	 LOG("gT2Kevgen", pERROR) 
           << "";
         continue;
     }

     LOG("gT2Kevgen", pINFO) << "Generated event: " << *event;

     // a valid event was generated: extract flux info (parent decay/prod
     // position/kinematics) for that simulated event so that it can be 
     // passed-through
     flux_info = new flux::GJPARCNuFluxPassThroughInfo(
                          jparc_flux_driver->PassThroughInfo());

     // add event at the output ntuple, refresh the mc job monitor & clean-up
     ntpw.AddEventRecord(ievent, event);
     mcjmonitor.Update(ievent,event);

     ievent++;
     delete event;
  }

  // Save the generated MC events
  ntpw.Save();

  return 0;
}
//____________________________________________________________________________
void GetCommandLineArgs(int argc, char ** argv)
{
// get gT2Kevgen command line arguments

  // help?
  bool help = genie::utils::clap::CmdLineArgAsBool(argc,argv,'h');
  if(help) {
      PrintSyntax();
      exit(0);
  }

  LOG("gT2Kevgen", pNOTICE) << "Parsing command line arguments";

  // run number:
  try {
    LOG("gT2Kevgen", pDEBUG) << "Reading MC run number";
    gOptRunNu = genie::utils::clap::CmdLineArgAsInt(argc,argv,'r');
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("gT2Kevgen", pDEBUG) << "Unspecified run number - Using default";
      gOptRunNu = kDefOptRunNu;
    }
  }

  //
  // *** geometry
  //

  string geom = "";
  string lunits, dunits;
  try {
    LOG("Main", pDEBUG) << "Getting input geometry";
    geom = genie::utils::clap::CmdLineArgAsString(argc,argv,'g');

    // is it a ROOT file that contains a ROOT geometry?
    bool accessible_geom_file = 
            ! (gSystem->AccessPathName(geom.c_str()));
    if (accessible_geom_file) {
      gOptRootGeom      = geom;
      gOptUsingRootGeom = true;
    }                 
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("Main", pFATAL) 
        << "No geometry option specified - Exiting";
      PrintSyntax();
      exit(1);
    }
  }

  if(gOptUsingRootGeom) {
     // using a ROOT geometry - get requested geometry units

     // legth units:
     try {
        LOG("Main", pDEBUG) 
           << "Checking for input geometry length units";
        lunits = genie::utils::clap::CmdLineArgAsString(argc,argv,'L');
     } catch(exceptions::CmdLineArgParserException e) {
        if(!e.ArgumentFound()) {
            LOG("Main", pDEBUG) << "Using default geometry length units";
            lunits = kDefOptGeomLUnits;
        }
     } // try-catch (-L)
     // density units:
     try {
        LOG("Main", pDEBUG) 
           << "Checking for input geometry density units";
        dunits = genie::utils::clap::CmdLineArgAsString(argc,argv,'D');
     } catch(exceptions::CmdLineArgParserException e) {
        if(!e.ArgumentFound()) {
            LOG("Main", pDEBUG) << "Using default geometry density units";
            dunits = kDefOptGeomDUnits;
        }
     } // try-catch (-D) 
     gOptGeomLUnits = genie::utils::units::UnitFromString(lunits);
     gOptGeomDUnits = genie::utils::units::UnitFromString(dunits);

     // check whether an event generation volume name has been 
     // specified -- default is the 'top volume'
     try {
        LOG("Main", pDEBUG) << "Checking for input volume name";
        gOptRootGeomTopVol = 
            genie::utils::clap::CmdLineArgAsString(argc,argv,'v');
     } catch(exceptions::CmdLineArgParserException e) {
        if(!e.ArgumentFound()) {
            LOG("Main", pDEBUG) << "Using the <master volume>";
        }
     } // try-catch (-v) 

     // check whether an XML file with the maximum (density weighted)
     // path lengths for each detector material is specified -
     // otherwise will compute the max path lengths at job init
     try {
        LOG("Main", pDEBUG) 
              << "Checking for maximum path lengths XML file";
        gOptExtMaxPlXml = 
            genie::utils::clap::CmdLineArgAsString(argc,argv,'p');
     } catch(exceptions::CmdLineArgParserException e) {
        if(!e.ArgumentFound()) {
            LOG("Main", pDEBUG) 
              << "Will compute the maximum path lengths at job init";
            gOptExtMaxPlXml = "";
        }
     } // try-catch (-v) 


  } // using root geom?

  else {
    gOptTgtMix.clear();
    vector<string> tgtmix = utils::str::Split(geom,",");
    if(tgtmix.size()==1) {
         int    pdg = atoi(tgtmix[0].c_str());
         double wgt = 1.0;
         gOptTgtMix.insert(map<int, double>::value_type(pdg, wgt));    
    } else {
      vector<string>::const_iterator tgtmix_iter = tgtmix.begin();
      for( ; tgtmix_iter != tgtmix.end(); ++tgtmix_iter) {
   	 string tgt_with_wgt = *tgtmix_iter;
	 string::size_type open_bracket  = tgt_with_wgt.find("[");
	 string::size_type close_bracket = tgt_with_wgt.find("]");
         if(1) {
         }
	 string::size_type ibeg = 0;
	 string::size_type iend = open_bracket;
	 string::size_type jbeg = open_bracket+1;
	 string::size_type jend = close_bracket-1;
         int    pdg = atoi(tgt_with_wgt.substr(ibeg,iend).c_str());
         double wgt = atof(tgt_with_wgt.substr(jbeg,jend).c_str());
         LOG("Main", pDEBUG) 
            << "Adding to target mix: pdg = " << pdg << ", wgt = " << wgt;
         gOptTgtMix.insert(map<int, double>::value_type(pdg, wgt));
      }//tgtmix_iter
    }//>1
 }

  //
  // *** flux 
  // 
  try {
    LOG("Main", pDEBUG) << "Getting input flux file";
    gOptFluxFile =
             genie::utils::clap::CmdLineArgAsString(argc,argv,'f');
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("Main", pFATAL) << "No flux file was specified - Exiting";
      PrintSyntax();
      exit(1);
    }
  }

  // limit on max number of events that can be generated
  try {
    LOG("gT2Kevgen", pDEBUG) 
        << "Reading limit on number of events to generate";
    gOptMaxNev = genie::utils::clap::CmdLineArgAsInt(argc,argv,'n');
  } catch(exceptions::CmdLineArgParserException e) {
    if(!e.ArgumentFound()) {
      LOG("gT2Kevgen", pDEBUG)
        << "Will keep on generating events till the flux driver stops";
      gOptMaxNev = kDefOptMaxNev;
    }
  }

  //
  // print the command line options
  //

  ostringstream gminfo;
  if (gOptUsingRootGeom) {
    gminfo << "using ROOT geom file = " << gOptRootGeom 
           << ", top volume: " 
           << ((gOptRootGeomTopVol.size()==0) ? "<master volume>" : gOptRootGeomTopVol)
           << ", max{PL} file: " 
           << ((gOptExtMaxPlXml.size()==0) ? "<none>" : gOptExtMaxPlXml)
           << ", length  units  = " << lunits
           << ", density units  = " << dunits;
  } else {
    PDGLibrary * pdglib = PDGLibrary::Instance();
    gminfo << "using target mix: ";
    map<int,double>::const_iterator iter;
    for(iter = gOptTgtMix.begin(); iter != gOptTgtMix.end(); ++iter) {
          int    pdg_code = iter->first;
          double wgt      = iter->second;
          TParticlePDG * p = pdglib->Find(pdg_code);
          if(p) {
            string name = p->GetName();
            gminfo 
             << pdg_code  << " (" << name << "): " << 100*wgt << "% / ";
          }//p?
    }
  }
  LOG("gT2Kevgen", pNOTICE) 
     << "\n MC Job (" << gOptRunNu << ") Settings: "
     << "\n - Flux     : using JPARC ntuple = " << gOptFluxFile
     << "\n - Geometry : " << gminfo.str();
}
//____________________________________________________________________________
void PrintSyntax(void)
{
  LOG("gT2Kevgen", pNOTICE)
    << "\n\n" << "Syntax:" << "\n"
    << "   gT2Kevgen <need to type options> \n";
}
//____________________________________________________________________________
