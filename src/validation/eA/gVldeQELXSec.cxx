//____________________________________________________________________________________________
/*!

\program gvld_e_qel_xsec

\brief   Compares GENIE with quasi-elastic electron scattering data.

         The data come from the Quasielastic Electron Nucleus Scattering Data
         Archive maintained by Donal Day:
         http://http://faculty.virginia.edu/qes-archive/
         See also O. Benhar, D. Day and I. Sick, Rev.Mod.Phys.80, 189, 2008
         A local copy of the data may be found in:
         $GENIE/data/validation/eA/xsec/differential/qe
         The archive contains ~19k data points.

         Syntax:
           gvld_e_qel_xsec 
                 [-g input_file_list] 
                 [-d data_archive]
                 [-s datasets_to_plot]

         Options:

           [] Denotes an optional argument.

           -d Full path to the electron QE archive.
              By default, will pick the one at:
              $GENIE/data/validation/eA/xsec/differential/qe/eQE.root

           -s Info on which datasets to plot. 
              By default, will pick the one at:
              $GENIE/data/validation/eA/xsec/differential/qe/datasets.txt

           -g An XML file with GENIE inputs (cross sections and event samples).
              If not set, only data -no GENIE predictions- will be displayed.
              Multiple models can be included in the input file, each identified
              by a "name" (all model predictions will be overlayed).
              For info on the XML file format see the GSimFiles class documentation.
              Notes:
              - The inputs for this benchmark test are prepared by the scipt
                submit_eA_xsec_validation_mc_jobs.pl
              - The input event files are `gst' summary ntuples generated by
                GENIE gntpc utility.

\author  Costas Andreopoulos <costas.andreopoulos \at stfc.ac.uk>
         STFC, Rutherford Appleton Laboratory

\created Oct 16, 2009 

\cpright Copyright (c) 2003-2011, GENIE Neutrino MC Generator Collaboration
         For the full text of the license visit http://copyright.genie-mc.org
         or see $GENIE/LICENSE
*/
//____________________________________________________________________________________________

#include <cstdlib>
#include <cassert>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>

#include <TSystem.h>
#include <TFile.h>
#include <TDirectory.h>
#include <TGraph.h>
#include <TGraphErrors.h>
#include <TPostScript.h>
#include <TLatex.h>
#include <TH1D.h>
#include <TH2D.h>
#include <TMath.h>
#include <TCanvas.h>
#include <TPavesText.h>
#include <TText.h>
#include <TLegend.h>
#include <TBox.h>

#include "Conventions/Constants.h"
#include "Conventions/Units.h"
#include "Messenger/Messenger.h"
#include "PDG/PDGUtils.h"
#include "PDG/PDGCodes.h"
#include "PDG/PDGLibrary.h"
#include "Utils/CmdLnArgParser.h"
#include "Utils/GSimFiles.h"
#include "Utils/SystemUtils.h"
#include "Utils/Style.h"

using std::ostringstream;
using std::ifstream;
using std::string;
using std::vector;

using namespace genie;
using namespace genie::constants;

//.................................................................................
// Utility class to hold info on plotted datasets
//
class eQEDataSetDescription
{
public:
  eQEDataSetDescription(
     int tgtpdg, string citation, double E, double theta) :
    fTgtPdg   (tgtpdg), 
    fCitation (citation), 
    fE        (E), 
    fTheta    (theta)
  {   
  }
  eQEDataSetDescription() 
  {   
  }
  int    TgtPdg   (void) const { return fTgtPdg; }
  int    TgtZ     (void) const { return pdg::IonPdgCodeToZ(fTgtPdg); }
  int    TgtA     (void) const { return pdg::IonPdgCodeToA(fTgtPdg); }
  string TgtName  (void) const { 
    if(fTgtPdg == 1000010010) return "1H";
    if(fTgtPdg == 1000010020) return "2D";
    if(fTgtPdg == 1000010030) return "3H";
    if(fTgtPdg == 1000020030) return "3He";
    if(fTgtPdg == 1000020040) return "4He";
    if(fTgtPdg == 1000060120) return "12C";
    if(fTgtPdg == 1000080160) return "16O";
    if(fTgtPdg == 1000130270) return "27Al";
    if(fTgtPdg == 1000200400) return "40Ca";
    if(fTgtPdg == 1000200480) return "48Ca";
    if(fTgtPdg == 1000260560) return "56Fe";
    if(fTgtPdg == 1000791970) return "197Au";
    if(fTgtPdg == 1000822080) return "208Pb";
    if(fTgtPdg == 1000922380) return "238U";
    return "Other";
  }
  string Citation (void) const { return fCitation; }
  double E        (void) const { return fE; }
  double Theta    (void) const { return fTheta; }
  string LabelTeX (void) const { 
    ostringstream label;
    label << this->TgtName() << "(e,e^{'}) ";
    label << "E = " << fE << " GeV, ";
    label << "#theta = " << fTheta << "^{o}";
    //label << " [" << fCitation << "]";
    return label.str();
  }
private:
  int    fTgtPdg;   //
  string fCitation; //
  double fE;        //
  double fTheta;    //
};
//.................................................................................

//
// constants
//

// defaults
const char * kDefDataArchiveFilename = "data/validation/eA/xsec/differential/qe/eQE.root";  
const char * kDefDataSetsFilename    = "data/validation/eA/xsec/differential/qe/datasets.txt";  

// plot config
const int kNCx = 2; // number of columns in TCanvas::Divide()
const int kNCy = 2; // number of rows    in TCanvas::Divide()

// model line styles
const int kNMaxNumModels = 5;
const int kLStyle[kNMaxNumModels] = 
{
   1, 2,  3,  5, 6
};
string kLStyleTxt[kNMaxNumModels] = 
{
  "solid", "dashed", "dotted", "dot-dashed", "dot-dot-dashed"
};

//
// globals
//

string gOptDataArchiveFilename = ""; // -d command-line argument
string gOptDataSetsFilename    = ""; // -s command-line argument
string gOptGenieFileList       = ""; // -g command-line argument

TFile *        gQEDataFile  = 0;
TTree *        gQEDataTree  = 0;
TPostScript *  gPS          = 0;
TCanvas *      gC           = 0;
bool           gShowModel   = false;

GSimFiles gGenieInputs;

vector<eQEDataSetDescription *> gDataSets; // list of plotted datasets

//
// function prototypes
//

void             Init               (void);
void             End                (void);
TGraphErrors *   Data               (int iset);
vector<TGraph *> Model              (int iset, int imodel);
void             Draw               (int iset);
void             GetCommandLineArgs (int argc, char ** argv);
void             PrintSyntax        (void);


//_________________________________________________________________________________
int main(int argc, char ** argv)
{
  GetCommandLineArgs (argc,argv);

  Init();

  // loop over data sets and plot data and corresponding GENIE predictions
  for(unsigned int iset = 0; iset < gDataSets.size(); iset++) 
  {
    LOG("gvldtest", pNOTICE) 
      << "Producing plots for: " << gDataSets[iset]->LabelTeX();
    Draw(iset);
  }

  End();

  LOG("gvldtest", pINFO)  << "Done!";
  return 0;
}
//_________________________________________________________________________________
void Init(void)
{
  LOG("gvldtest", pNOTICE) << "Initializing...";

  // Set GENIE style
  utils::style::SetDefaultStyle();

  //
  // Get TTree with electron-scattering data
  //
  if( ! utils::system::FileExists(gOptDataArchiveFilename) ) {
      LOG("gvldtest", pFATAL) 
         << "Can not find file: " << gOptDataArchiveFilename;
      gAbortingInErr = true;
      exit(1);
  }
  gQEDataFile = new TFile(gOptDataArchiveFilename.c_str(),"read");  
  gQEDataTree = (TTree *) gQEDataFile->Get("qent");
  if(!gQEDataTree) {
      LOG("gvldtest", pFATAL) 
         << "Can not find TTree `qent' in file: " << gOptDataArchiveFilename;
      gAbortingInErr = true;
      exit(1);
  }

  //
  // Read information on which data-sets to plot
  //
  LOG("gvldtest", pDEBUG) 
    << "Reading dataset summary info from: " << gOptDataSetsFilename;
  ifstream summary_file(gOptDataSetsFilename.c_str());
  if (!summary_file.good() ) {
      LOG("gvldtest", pFATAL) 
         << "Can't open data summary file: " << gOptDataSetsFilename;
      gAbortingInErr = true;
      exit(1);
  }
  while(1) {
      // skip header lines staring with #
      if(summary_file.peek() == '#') {
         summary_file.ignore(1000, '\n');
       } else {
         int    target   = 0;
         string citation = "";
         double E        = 0;
         double theta    = 0;
         summary_file >> target >> citation >> E >> theta;
         summary_file.ignore(1000, '\n');
         if(summary_file.eof()) break;            

         LOG("gvldtest", pNOTICE) 
            << "target: " << target << ", citation: " << citation
            << ", E = " << E << " GeV, theta = " << theta << " deg";

         eQEDataSetDescription * dataset = 
                 new eQEDataSetDescription(target,citation,E,theta);
         gDataSets.push_back(dataset);
       }
  }
  summary_file.close();
  LOG("gvldtest", pNOTICE) 
     << "Read "  << gDataSets.size() << " datasets";

  // Read GENIE inputs
  if(gShowModel) {
    bool ok = gGenieInputs.LoadFromFile(gOptGenieFileList);
    if(!ok) {
       LOG("gtune", pFATAL)
         << "Could not read GENIE inputs specified in XML file: "
         << gOptGenieFileList;
       gAbortingInErr = true;
       exit(1);
    }
  }

  // Create plot canvas
  gC = new TCanvas("c","",20,20,500,650);
  gC->SetBorderMode(0);
  gC->SetFillColor(0);
  gC->SetGridx();
  gC->SetGridy();

 // Get local time to tag outputs
  string lt_for_filename   = utils::system::LocalTimeAsString("%02d.%02d.%02d_%02d.%02d.%02d");
  string lt_for_cover_page = utils::system::LocalTimeAsString("%02d/%02d/%02d %02d:%02d:%02d");

  // Create output postscript file
  string filename  = Form("genie-e_qe_data_comp-%s.ps",lt_for_filename.c_str());
  gPS = new TPostScript(filename.c_str(), 111);

  // Add cover page
  gPS->NewPage();
  gC->Range(0,0,100,100);
  TPavesText hdr(10,40,90,70,3,"tr");
  hdr.AddText(" ");
  hdr.AddText("GENIE comparison with e QE data");
  hdr.AddText(" ");
  hdr.AddText(" ");
  hdr.AddText(" ");
  hdr.AddText(" ");
  hdr.AddText(lt_for_cover_page.c_str());
  hdr.AddText(" ");
  hdr.Draw();
  gC->Update();
}
//_________________________________________________________________________________
void End(void)
{
  LOG("gvldtest", pNOTICE) << "Cleaning up...";

  gPS->Close();

  delete gC;
  delete gPS;

  gQEDataFile->Close();
}
//_________________________________________________________________________________
vector<TGraph *> Model(int iset, int imodel)
{
// Corresponding GENIE prediction for the `iset' data set 

  vector<TGraph *> model;

  if(!gShowModel) return model;

  LOG("gvldtest", pNOTICE) 
    << "Getting GENIE prediction (model ID = " 
    << imodel << ", data set ID = " << iset << ")";

  TFile * xsec_file = gGenieInputs.XSecFile(imodel);
  if(!xsec_file) {
     LOG("gvldtest", pFATAL)
        << "No corresponding cross section file";
     exit(1);
  }
  TChain * event_chain = gGenieInputs.EvtChain(imodel);
  if(!event_chain) {
     LOG("gvldtest", pFATAL)
        << "No corresponding event chain.";
     exit(1);
  }
  
  int    Z     = gDataSets[iset]->TgtZ();
  int    A     = gDataSets[iset]->TgtA();
  double E     = gDataSets[iset]->E();
  double theta = gDataSets[iset]->Theta();
  double costheta = TMath::Cos(kPi*theta/180.);

  double Emin        = E - 0.001;
  double Emax        = E + 0.001;
  double costhetamin = costheta - 0.03;
  double costhetamax = costheta + 0.03;
  costhetamin = TMath::Max(-1.0, costhetamin);
  costhetamax = TMath::Min( 1.0, costhetamax);

  // get total cross section
  PDGLibrary * pdglib = PDGLibrary::Instance();
  int tgtpdg = pdg::IonPdgCode(A,Z);
  const char * tgtname = pdglib->Find(tgtpdg)->GetName();
  const char * dirname = Form("e-_%s",tgtname);
  const char * xsec_spline_name = "tot_em";
  TDirectory * dir = (TDirectory*)xsec_file->Get(dirname);
  TGraph * xsec_em_gr = (TGraph*)dir->Get(xsec_spline_name);
  if(!xsec_em_gr) {
     LOG("vldtest", pFATAL)
        << "Null E/M cross section graph";
     exit(1);
  }
  double xsec_em = xsec_em_gr->Eval(E); 
  xsec_em *= (1E-38  * units::cm2 / units::nb); // convert to nbarn
  if(xsec_em <= 0) {
     LOG("vldtest", pFATAL)
        << "Non-positive E/M cross-section";
     exit(1);
  }
  LOG("gvldtest", pNOTICE)
    << "e- + " << tgtname << " total cross-section (E = " << E << " GeV) = " 
    << xsec_em << " nbarn";

  event_chain->Draw("1", Form("(Ev>=%f)&&(Ev<%f)&&(Z==%d)&&(A==%d)&&(em)",Emin,Emax,Z,A), "GOFF");
  double nentries_all = event_chain->GetSelectedRows();
  LOG("gvldtest", pNOTICE)
    << "Selected " << nentries_all << " MC events for E = " << E << " GeV"; 
  if(nentries_all <= 0.)  {
    return model;
  }

  const int nbins = 40;

  double dv = E/nbins;
  double dcostheta = costhetamax-costhetamin;

  double scale = xsec_em / (2*kPi*nentries_all*dv*dcostheta);
  LOG("gvldtest", pNOTICE)
     << "Scaling factor: " << scale;

  const int ngraphs = 5;

  const char * select_events_in_costheta_bin[ngraphs] = {
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em)", 
            Emin, Emax, costhetamin, costhetamax, Z, A),
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em&&qel)", 
            Emin, Emax, costhetamin, costhetamax, Z, A),
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em&&mec)",
            Emin, Emax, costhetamin, costhetamax, Z, A),
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em&&res)", 
            Emin, Emax, costhetamin, costhetamax, Z, A),
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em&&(!qel&&!mec&&!res))", 
            Emin, Emax, costhetamin, costhetamax, Z, A)
  };

  const char * label[ngraphs] = {
      "Total", "Quasi-elastic", "Meson Exchange", "Resonance", "Other" 
  };
  int color[ngraphs] = { kBlack, kBlue,  kBlue,   kRed,   kGreen };
  int style[ngraphs] = { kSolid, kSolid, kDashed, kSolid, kSolid };
  int width[ngraphs] = { 2,      1,      2,       1,      1      };

  for(int igr = 0; igr < ngraphs; igr++) {
      TH1D * v_distribution = new TH1D("v_distribution","",nbins,0,E);
      event_chain->Draw("Ev-El>>v_distribution", select_events_in_costheta_bin[igr], "goff");
      double nentries = event_chain->GetSelectedRows();
      LOG("gvldtest", pNOTICE)
          << "Selected " << nentries << " " << label[igr] << " events for E = " << E << " GeV"
          << " in costheta range [" << costhetamin << ", " << costhetamax << ")";     
      v_distribution->Scale(scale);
      double * v = new double[nbins]; 
      double * d2sigma_dEpdOmega = new double[nbins]; 
      for(int i=0; i<nbins; i++) {
         v[i] = v_distribution->GetBinCenter(i+1);
         d2sigma_dEpdOmega[i] = v_distribution->GetBinContent(i+1);
      }
      TGraph * gr = new TGraph(nbins,v,d2sigma_dEpdOmega);
      gr->SetTitle(label[igr]);
      utils::style::Format(gr, color[igr], style[igr], width[igr], 1,1,1);
      model.push_back(gr);
      delete [] v;
      delete [] d2sigma_dEpdOmega;
      delete v_distribution;
  }//igr

  return model;
}
//_________________________________________________________________________________
TGraphErrors * Data(int iset)
{
  const double dE      = 2.0E-3;
  const double dtheta  = 2.5E-2;

  int    Z        = gDataSets[iset]->TgtZ();
  int    A        = gDataSets[iset]->TgtA();
  double E        = gDataSets[iset]->E();
  double theta    = gDataSets[iset]->Theta();
  string citation = gDataSets[iset]->Citation();

  const char * selection = 
    Form("E > %f && E < %f && theta > %f && theta < %f && Z == %d && A == %d",
         E     - dE,
         E     + dE,
         theta - dtheta,
         theta + dtheta,
         Z,A);

  gQEDataTree->Draw("v:xsec:xsec_err", selection, "goff");
  
  int n = gQEDataTree->GetSelectedRows();

  LOG("gvldtest", pNOTICE) 
    << "Found " << n << " data points in the xsec archive";

  if(n == 0) return 0; // return null graph

  // Data returned by TTree::Draw() are not necessarily ordered in W
  // Do the ordering here before building the graph
  int    *  idx = new int   [n];
  double *  xv  = new double[n];
  double *  yv  = new double[n];
  double *  dyv = new double[n];

  TMath::Sort(n,gQEDataTree->GetV1(),idx,false);

  for(int i=0; i<n; i++) {
     int ii = idx[i];
     xv [i] = (gQEDataTree->GetV1())[ii];
     yv [i] = (gQEDataTree->GetV2())[ii];
     dyv[i] = (gQEDataTree->GetV3())[ii];
  }

  TGraphErrors * gr = new TGraphErrors(n,xv,yv,0,dyv);
  gr->SetTitle(citation.c_str());
  utils::style::Format(gr, 1,1,1,1,8,0.8);

  delete [] idx;
  delete [] xv;
  delete [] yv;
  delete [] dyv;

  return gr;
}
//_________________________________________________________________________________
void Draw(int iset)
{
  // get all measurements for the current channel from the NuValidator MySQL dbase
  TGraphErrors * data = Data(iset);
  if(!data) return;

  // get the corresponding GENIE model prediction
  vector<TGraph *> model = Model(iset,0);

  int plots_per_page = kNCx * kNCy;
  int iplot = 1 + iset % plots_per_page;

  if(iplot == 1) {
     gPS->NewPage();
     gC -> Clear();
     gC -> Divide(kNCx,kNCy);
  }

  gC -> GetPad(iplot) -> Range(0,0,100,100);
  gC -> GetPad(iplot) -> SetFillColor(0);
  gC -> GetPad(iplot) -> SetBorderMode(0);
  gC -> GetPad(iplot) -> cd();

  //
  // draw frame
  //

  TH1F * hframe = 0;

  double xmin = 0.0, scale_xmin = 0.5;
  double xmax = 0.0, scale_xmax = 1.2;
  double ymin = 0.0, scale_ymin = 0.4;
  double ymax = 0.0, scale_ymax = 1.2;

  xmin  = ( data->GetX() )[TMath::LocMin(data->GetN(),data->GetX())];
  xmax  = ( data->GetX() )[TMath::LocMax(data->GetN(),data->GetX())];
  ymin  = ( data->GetY() )[TMath::LocMin(data->GetN(),data->GetY())];
  ymax  = ( data->GetY() )[TMath::LocMax(data->GetN(),data->GetY())];
 
  for(unsigned int ic = 0; ic < model.size(); ic++) 
  {  
     ymin = TMath::Min(ymin, 
        (model[ic]->GetY())[TMath::LocMin(model[ic]->GetN(),model[ic]->GetY())]);
     ymax = TMath::Max(ymax, 
        (model[ic]->GetY())[TMath::LocMax(model[ic]->GetN(),model[ic]->GetY())]);
  }
  hframe = (TH1F*) gC->GetPad(iplot)->DrawFrame(
        scale_xmin*xmin, scale_ymin*ymin, scale_xmax*xmax, scale_ymax*ymax);

  hframe->GetXaxis()->SetTitle("#nu = E-E^{'} (GeV)");
  hframe->GetYaxis()->SetTitle("d^{2}#sigma / d#Omega dE (nb/sr/GeV)");
  hframe->GetXaxis()->SetLabelFont(62);
  hframe->GetYaxis()->SetLabelFont(62);
  hframe->GetXaxis()->SetLabelSize(0.04);
  hframe->GetYaxis()->SetLabelSize(0.04);
  hframe->GetXaxis()->SetTitleSize(0.04);
  hframe->GetYaxis()->SetTitleSize(0.04);
  hframe->GetYaxis()->SetTitleOffset(1.65);
  hframe->Draw();
 
  //
  // draw expt data and GENIE predictions & add legend
  //
  TLegend * legend = new TLegend(0.55, 0.70, 0.85, 0.88);
  legend->SetLineStyle(0);
  legend->SetFillColor(0);
  legend->SetFillStyle(0);
  legend->SetTextSize(0.04);

  data->Draw("P");
  legend->AddEntry(data,data->GetTitle(),"P");
  for(unsigned int ic = 0; ic < model.size(); ic++) 
  {  
    model[ic]->Draw("L");
    legend->AddEntry(model[ic],model[ic]->GetTitle(),"L");
  }
  legend->Draw();

  // title
  TLatex * title = new TLatex(
     scale_xmin*xmin + 0.2*(scale_xmax*xmax-scale_xmin*xmin),
    1.01*scale_ymax*ymax,gDataSets[iset]->LabelTeX().c_str());
  title->SetTextSize(0.027);
  title->Draw();

  gC->GetPad(iplot)->Update();
  gC->Update();
}
//_________________________________________________________________________________
// Parsing command-line arguments, check/form filenames, etc
//.................................................................................
void GetCommandLineArgs(int argc, char ** argv)
{
  LOG("gvldtest", pNOTICE) << "*** Parsing command line arguments";

  CmdLnArgParser parser(argc,argv);

  if(parser.OptionExists('d')){
     string filename = parser.ArgAsString('d');
     gOptDataArchiveFilename = filename;
  } else {
     if(gSystem->Getenv("GENIE")) {
        string base_dir = string( gSystem->Getenv("GENIE") );
        string filename = base_dir + "/" + kDefDataArchiveFilename;
        gOptDataArchiveFilename = filename;
     } else {
        LOG("gvldtest", pFATAL)
          << "\n Please make sure that $GENIE is defined, or use the -d option"
          << "\n You didn't specify a data file and I can not pick the default one either";
        gAbortingInErr = true;
        exit(1);
     }
  }

  if(parser.OptionExists('s')){
     string filename = parser.ArgAsString('s');
     gOptDataSetsFilename = filename;
  } else {
     if(gSystem->Getenv("GENIE")) {
        string base_dir = string( gSystem->Getenv("GENIE") );
        string filename = base_dir + "/" + kDefDataSetsFilename;
        gOptDataSetsFilename = filename;
     } else {
        LOG("gvldtest", pFATAL)
          << "\n Please make sure that $GENIE is defined, or use the -s option"
          << "\n You didn't specify a data file and I can not pick the default one either";
        gAbortingInErr = true;
        exit(1);
     }
  }

  // get GENIE inputs
  gShowModel = false;
  if( parser.OptionExists('g') ) {
     gOptGenieFileList = parser.ArgAsString('g');
     gShowModel = true;
  } 

}
//_________________________________________________________________________________
void PrintSyntax(void)
{
  LOG("gvldtest", pNOTICE)
    << "\n\n" << "Syntax:" << "\n"
    << "  gvld_e_qel_xsec -g inputs [-d data_archive_location]\n";
}
//_________________________________________________________________________________
